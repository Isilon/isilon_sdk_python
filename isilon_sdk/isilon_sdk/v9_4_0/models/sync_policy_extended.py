# coding: utf-8

"""
    Isilon SDK

    Isilon SDK - Language bindings for the OneFS API  # noqa: E501

    OpenAPI spec version: 15
    Contact: sdk@isilon.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from isilon_sdk.v9_4_0.models.sync_policy_file_matching_pattern import SyncPolicyFileMatchingPattern  # noqa: F401,E501
from isilon_sdk.v9_4_0.models.sync_policy_source_network import SyncPolicySourceNetwork  # noqa: F401,E501


class SyncPolicyExtended(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'accelerated_failback': 'bool',
        'action': 'str',
        'allow_copy_fb': 'bool',
        'bandwidth_reservation': 'int',
        'changelist': 'bool',
        'check_integrity': 'bool',
        'cloud_deep_copy': 'str',
        'conflicted': 'bool',
        'database_mirrored': 'bool',
        'delete_quotas': 'bool',
        'description': 'str',
        'disable_file_split': 'bool',
        'disable_fofb': 'bool',
        'disable_quota_tmp_dir': 'bool',
        'disable_stf': 'bool',
        'enable_hash_tmpdir': 'bool',
        'enabled': 'bool',
        'encrypted': 'bool',
        'encryption_cipher_list': 'str',
        'expected_dataloss': 'bool',
        'file_matching_pattern': 'SyncPolicyFileMatchingPattern',
        'force_interface': 'bool',
        'has_sync_state': 'bool',
        'id': 'str',
        'ignore_recursive_quota': 'bool',
        'job_delay': 'int',
        'last_job_state': 'str',
        'last_started': 'int',
        'last_success': 'int',
        'linked_service_policies': 'list[str]',
        'log_level': 'str',
        'log_removed_files': 'bool',
        'name': 'str',
        'next_run': 'int',
        'ocsp_address': 'str',
        'ocsp_issuer_certificate_id': 'str',
        'password_set': 'bool',
        'priority': 'int',
        'report_max_age': 'int',
        'report_max_count': 'int',
        'restrict_target_network': 'bool',
        'rpo_alert': 'int',
        'schedule': 'str',
        'service_policy': 'bool',
        'skip_lookup': 'bool',
        'skip_when_source_unmodified': 'bool',
        'snapshot_sync_existing': 'bool',
        'snapshot_sync_pattern': 'str',
        'source_certificate_id': 'str',
        'source_domain_marked': 'bool',
        'source_exclude_directories': 'list[str]',
        'source_include_directories': 'list[str]',
        'source_network': 'SyncPolicySourceNetwork',
        'source_root_path': 'str',
        'source_snapshot_archive': 'bool',
        'source_snapshot_expiration': 'int',
        'source_snapshot_pattern': 'str',
        'sync_existing_snapshot_expiration': 'bool',
        'sync_existing_target_snapshot_pattern': 'str',
        'target_certificate_id': 'str',
        'target_compare_initial_sync': 'bool',
        'target_detect_modifications': 'bool',
        'target_host': 'str',
        'target_path': 'str',
        'target_snapshot_alias': 'str',
        'target_snapshot_archive': 'bool',
        'target_snapshot_expiration': 'int',
        'target_snapshot_pattern': 'str',
        'workers_per_node': 'int'
    }

    attribute_map = {
        'accelerated_failback': 'accelerated_failback',
        'action': 'action',
        'allow_copy_fb': 'allow_copy_fb',
        'bandwidth_reservation': 'bandwidth_reservation',
        'changelist': 'changelist',
        'check_integrity': 'check_integrity',
        'cloud_deep_copy': 'cloud_deep_copy',
        'conflicted': 'conflicted',
        'database_mirrored': 'database_mirrored',
        'delete_quotas': 'delete_quotas',
        'description': 'description',
        'disable_file_split': 'disable_file_split',
        'disable_fofb': 'disable_fofb',
        'disable_quota_tmp_dir': 'disable_quota_tmp_dir',
        'disable_stf': 'disable_stf',
        'enable_hash_tmpdir': 'enable_hash_tmpdir',
        'enabled': 'enabled',
        'encrypted': 'encrypted',
        'encryption_cipher_list': 'encryption_cipher_list',
        'expected_dataloss': 'expected_dataloss',
        'file_matching_pattern': 'file_matching_pattern',
        'force_interface': 'force_interface',
        'has_sync_state': 'has_sync_state',
        'id': 'id',
        'ignore_recursive_quota': 'ignore_recursive_quota',
        'job_delay': 'job_delay',
        'last_job_state': 'last_job_state',
        'last_started': 'last_started',
        'last_success': 'last_success',
        'linked_service_policies': 'linked_service_policies',
        'log_level': 'log_level',
        'log_removed_files': 'log_removed_files',
        'name': 'name',
        'next_run': 'next_run',
        'ocsp_address': 'ocsp_address',
        'ocsp_issuer_certificate_id': 'ocsp_issuer_certificate_id',
        'password_set': 'password_set',
        'priority': 'priority',
        'report_max_age': 'report_max_age',
        'report_max_count': 'report_max_count',
        'restrict_target_network': 'restrict_target_network',
        'rpo_alert': 'rpo_alert',
        'schedule': 'schedule',
        'service_policy': 'service_policy',
        'skip_lookup': 'skip_lookup',
        'skip_when_source_unmodified': 'skip_when_source_unmodified',
        'snapshot_sync_existing': 'snapshot_sync_existing',
        'snapshot_sync_pattern': 'snapshot_sync_pattern',
        'source_certificate_id': 'source_certificate_id',
        'source_domain_marked': 'source_domain_marked',
        'source_exclude_directories': 'source_exclude_directories',
        'source_include_directories': 'source_include_directories',
        'source_network': 'source_network',
        'source_root_path': 'source_root_path',
        'source_snapshot_archive': 'source_snapshot_archive',
        'source_snapshot_expiration': 'source_snapshot_expiration',
        'source_snapshot_pattern': 'source_snapshot_pattern',
        'sync_existing_snapshot_expiration': 'sync_existing_snapshot_expiration',
        'sync_existing_target_snapshot_pattern': 'sync_existing_target_snapshot_pattern',
        'target_certificate_id': 'target_certificate_id',
        'target_compare_initial_sync': 'target_compare_initial_sync',
        'target_detect_modifications': 'target_detect_modifications',
        'target_host': 'target_host',
        'target_path': 'target_path',
        'target_snapshot_alias': 'target_snapshot_alias',
        'target_snapshot_archive': 'target_snapshot_archive',
        'target_snapshot_expiration': 'target_snapshot_expiration',
        'target_snapshot_pattern': 'target_snapshot_pattern',
        'workers_per_node': 'workers_per_node'
    }

    def __init__(self, accelerated_failback=None, action=None, allow_copy_fb=None, bandwidth_reservation=None, changelist=None, check_integrity=None, cloud_deep_copy=None, conflicted=None, database_mirrored=None, delete_quotas=None, description=None, disable_file_split=None, disable_fofb=None, disable_quota_tmp_dir=None, disable_stf=None, enable_hash_tmpdir=None, enabled=None, encrypted=None, encryption_cipher_list=None, expected_dataloss=None, file_matching_pattern=None, force_interface=None, has_sync_state=None, id=None, ignore_recursive_quota=None, job_delay=None, last_job_state=None, last_started=None, last_success=None, linked_service_policies=None, log_level=None, log_removed_files=None, name=None, next_run=None, ocsp_address=None, ocsp_issuer_certificate_id=None, password_set=None, priority=None, report_max_age=None, report_max_count=None, restrict_target_network=None, rpo_alert=None, schedule=None, service_policy=None, skip_lookup=None, skip_when_source_unmodified=None, snapshot_sync_existing=None, snapshot_sync_pattern=None, source_certificate_id=None, source_domain_marked=None, source_exclude_directories=None, source_include_directories=None, source_network=None, source_root_path=None, source_snapshot_archive=None, source_snapshot_expiration=None, source_snapshot_pattern=None, sync_existing_snapshot_expiration=None, sync_existing_target_snapshot_pattern=None, target_certificate_id=None, target_compare_initial_sync=None, target_detect_modifications=None, target_host=None, target_path=None, target_snapshot_alias=None, target_snapshot_archive=None, target_snapshot_expiration=None, target_snapshot_pattern=None, workers_per_node=None):  # noqa: E501
        """SyncPolicyExtended - a model defined in Swagger"""  # noqa: E501

        self._accelerated_failback = None
        self._action = None
        self._allow_copy_fb = None
        self._bandwidth_reservation = None
        self._changelist = None
        self._check_integrity = None
        self._cloud_deep_copy = None
        self._conflicted = None
        self._database_mirrored = None
        self._delete_quotas = None
        self._description = None
        self._disable_file_split = None
        self._disable_fofb = None
        self._disable_quota_tmp_dir = None
        self._disable_stf = None
        self._enable_hash_tmpdir = None
        self._enabled = None
        self._encrypted = None
        self._encryption_cipher_list = None
        self._expected_dataloss = None
        self._file_matching_pattern = None
        self._force_interface = None
        self._has_sync_state = None
        self._id = None
        self._ignore_recursive_quota = None
        self._job_delay = None
        self._last_job_state = None
        self._last_started = None
        self._last_success = None
        self._linked_service_policies = None
        self._log_level = None
        self._log_removed_files = None
        self._name = None
        self._next_run = None
        self._ocsp_address = None
        self._ocsp_issuer_certificate_id = None
        self._password_set = None
        self._priority = None
        self._report_max_age = None
        self._report_max_count = None
        self._restrict_target_network = None
        self._rpo_alert = None
        self._schedule = None
        self._service_policy = None
        self._skip_lookup = None
        self._skip_when_source_unmodified = None
        self._snapshot_sync_existing = None
        self._snapshot_sync_pattern = None
        self._source_certificate_id = None
        self._source_domain_marked = None
        self._source_exclude_directories = None
        self._source_include_directories = None
        self._source_network = None
        self._source_root_path = None
        self._source_snapshot_archive = None
        self._source_snapshot_expiration = None
        self._source_snapshot_pattern = None
        self._sync_existing_snapshot_expiration = None
        self._sync_existing_target_snapshot_pattern = None
        self._target_certificate_id = None
        self._target_compare_initial_sync = None
        self._target_detect_modifications = None
        self._target_host = None
        self._target_path = None
        self._target_snapshot_alias = None
        self._target_snapshot_archive = None
        self._target_snapshot_expiration = None
        self._target_snapshot_pattern = None
        self._workers_per_node = None
        self.discriminator = None

        if accelerated_failback is not None:
            self.accelerated_failback = accelerated_failback
        if action is not None:
            self.action = action
        if allow_copy_fb is not None:
            self.allow_copy_fb = allow_copy_fb
        if bandwidth_reservation is not None:
            self.bandwidth_reservation = bandwidth_reservation
        if changelist is not None:
            self.changelist = changelist
        if check_integrity is not None:
            self.check_integrity = check_integrity
        if cloud_deep_copy is not None:
            self.cloud_deep_copy = cloud_deep_copy
        if conflicted is not None:
            self.conflicted = conflicted
        if database_mirrored is not None:
            self.database_mirrored = database_mirrored
        if delete_quotas is not None:
            self.delete_quotas = delete_quotas
        if description is not None:
            self.description = description
        if disable_file_split is not None:
            self.disable_file_split = disable_file_split
        if disable_fofb is not None:
            self.disable_fofb = disable_fofb
        if disable_quota_tmp_dir is not None:
            self.disable_quota_tmp_dir = disable_quota_tmp_dir
        if disable_stf is not None:
            self.disable_stf = disable_stf
        if enable_hash_tmpdir is not None:
            self.enable_hash_tmpdir = enable_hash_tmpdir
        self.enabled = enabled
        if encrypted is not None:
            self.encrypted = encrypted
        if encryption_cipher_list is not None:
            self.encryption_cipher_list = encryption_cipher_list
        if expected_dataloss is not None:
            self.expected_dataloss = expected_dataloss
        if file_matching_pattern is not None:
            self.file_matching_pattern = file_matching_pattern
        if force_interface is not None:
            self.force_interface = force_interface
        if has_sync_state is not None:
            self.has_sync_state = has_sync_state
        self.id = id
        if ignore_recursive_quota is not None:
            self.ignore_recursive_quota = ignore_recursive_quota
        if job_delay is not None:
            self.job_delay = job_delay
        if last_job_state is not None:
            self.last_job_state = last_job_state
        if last_started is not None:
            self.last_started = last_started
        if last_success is not None:
            self.last_success = last_success
        if linked_service_policies is not None:
            self.linked_service_policies = linked_service_policies
        if log_level is not None:
            self.log_level = log_level
        if log_removed_files is not None:
            self.log_removed_files = log_removed_files
        self.name = name
        if next_run is not None:
            self.next_run = next_run
        if ocsp_address is not None:
            self.ocsp_address = ocsp_address
        if ocsp_issuer_certificate_id is not None:
            self.ocsp_issuer_certificate_id = ocsp_issuer_certificate_id
        if password_set is not None:
            self.password_set = password_set
        if priority is not None:
            self.priority = priority
        if report_max_age is not None:
            self.report_max_age = report_max_age
        if report_max_count is not None:
            self.report_max_count = report_max_count
        if restrict_target_network is not None:
            self.restrict_target_network = restrict_target_network
        if rpo_alert is not None:
            self.rpo_alert = rpo_alert
        self.schedule = schedule
        if service_policy is not None:
            self.service_policy = service_policy
        if skip_lookup is not None:
            self.skip_lookup = skip_lookup
        if skip_when_source_unmodified is not None:
            self.skip_when_source_unmodified = skip_when_source_unmodified
        if snapshot_sync_existing is not None:
            self.snapshot_sync_existing = snapshot_sync_existing
        if snapshot_sync_pattern is not None:
            self.snapshot_sync_pattern = snapshot_sync_pattern
        if source_certificate_id is not None:
            self.source_certificate_id = source_certificate_id
        if source_domain_marked is not None:
            self.source_domain_marked = source_domain_marked
        if source_exclude_directories is not None:
            self.source_exclude_directories = source_exclude_directories
        if source_include_directories is not None:
            self.source_include_directories = source_include_directories
        if source_network is not None:
            self.source_network = source_network
        self.source_root_path = source_root_path
        if source_snapshot_archive is not None:
            self.source_snapshot_archive = source_snapshot_archive
        if source_snapshot_expiration is not None:
            self.source_snapshot_expiration = source_snapshot_expiration
        if source_snapshot_pattern is not None:
            self.source_snapshot_pattern = source_snapshot_pattern
        if sync_existing_snapshot_expiration is not None:
            self.sync_existing_snapshot_expiration = sync_existing_snapshot_expiration
        if sync_existing_target_snapshot_pattern is not None:
            self.sync_existing_target_snapshot_pattern = sync_existing_target_snapshot_pattern
        if target_certificate_id is not None:
            self.target_certificate_id = target_certificate_id
        if target_compare_initial_sync is not None:
            self.target_compare_initial_sync = target_compare_initial_sync
        if target_detect_modifications is not None:
            self.target_detect_modifications = target_detect_modifications
        self.target_host = target_host
        self.target_path = target_path
        if target_snapshot_alias is not None:
            self.target_snapshot_alias = target_snapshot_alias
        if target_snapshot_archive is not None:
            self.target_snapshot_archive = target_snapshot_archive
        if target_snapshot_expiration is not None:
            self.target_snapshot_expiration = target_snapshot_expiration
        if target_snapshot_pattern is not None:
            self.target_snapshot_pattern = target_snapshot_pattern
        if workers_per_node is not None:
            self.workers_per_node = workers_per_node

    @property
    def accelerated_failback(self):
        """Gets the accelerated_failback of this SyncPolicyExtended.  # noqa: E501

        If set to true, SyncIQ will perform failback configuration tasks during the next job run, rather than waiting to perform those tasks during the failback process. Performing these tasks ahead of time will increase the speed of failback operations.  # noqa: E501

        :return: The accelerated_failback of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._accelerated_failback

    @accelerated_failback.setter
    def accelerated_failback(self, accelerated_failback):
        """Sets the accelerated_failback of this SyncPolicyExtended.

        If set to true, SyncIQ will perform failback configuration tasks during the next job run, rather than waiting to perform those tasks during the failback process. Performing these tasks ahead of time will increase the speed of failback operations.  # noqa: E501

        :param accelerated_failback: The accelerated_failback of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._accelerated_failback = accelerated_failback

    @property
    def action(self):
        """Gets the action of this SyncPolicyExtended.  # noqa: E501

        If 'copy', source files will be copied to the target cluster.  If 'sync', the target directory will be made an image of the source directory:  Files and directories that have been deleted on the source, have been moved within the target directory, or no longer match the selection criteria will be deleted from the target directory.  # noqa: E501

        :return: The action of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._action

    @action.setter
    def action(self, action):
        """Sets the action of this SyncPolicyExtended.

        If 'copy', source files will be copied to the target cluster.  If 'sync', the target directory will be made an image of the source directory:  Files and directories that have been deleted on the source, have been moved within the target directory, or no longer match the selection criteria will be deleted from the target directory.  # noqa: E501

        :param action: The action of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        allowed_values = ["copy", "sync"]  # noqa: E501
        if action not in allowed_values:
            raise ValueError(
                "Invalid value for `action` ({0}), must be one of {1}"  # noqa: E501
                .format(action, allowed_values)
            )

        self._action = action

    @property
    def allow_copy_fb(self):
        """Gets the allow_copy_fb of this SyncPolicyExtended.  # noqa: E501

        If set to true, SyncIQ will allow a policy with copy action failback which is not supported by default.  # noqa: E501

        :return: The allow_copy_fb of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._allow_copy_fb

    @allow_copy_fb.setter
    def allow_copy_fb(self, allow_copy_fb):
        """Sets the allow_copy_fb of this SyncPolicyExtended.

        If set to true, SyncIQ will allow a policy with copy action failback which is not supported by default.  # noqa: E501

        :param allow_copy_fb: The allow_copy_fb of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._allow_copy_fb = allow_copy_fb

    @property
    def bandwidth_reservation(self):
        """Gets the bandwidth_reservation of this SyncPolicyExtended.  # noqa: E501

        The desired bandwidth reservation for this policy in kb/s. This feature will not activate unless a SyncIQ bandwidth rule is in effect.  # noqa: E501

        :return: The bandwidth_reservation of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._bandwidth_reservation

    @bandwidth_reservation.setter
    def bandwidth_reservation(self, bandwidth_reservation):
        """Sets the bandwidth_reservation of this SyncPolicyExtended.

        The desired bandwidth reservation for this policy in kb/s. This feature will not activate unless a SyncIQ bandwidth rule is in effect.  # noqa: E501

        :param bandwidth_reservation: The bandwidth_reservation of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if bandwidth_reservation is not None and bandwidth_reservation > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `bandwidth_reservation`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if bandwidth_reservation is not None and bandwidth_reservation < 0:  # noqa: E501
            raise ValueError("Invalid value for `bandwidth_reservation`, must be a value greater than or equal to `0`")  # noqa: E501

        self._bandwidth_reservation = bandwidth_reservation

    @property
    def changelist(self):
        """Gets the changelist of this SyncPolicyExtended.  # noqa: E501

        If true, retain previous source snapshot and incremental repstate, both of which are required for changelist creation.  # noqa: E501

        :return: The changelist of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._changelist

    @changelist.setter
    def changelist(self, changelist):
        """Sets the changelist of this SyncPolicyExtended.

        If true, retain previous source snapshot and incremental repstate, both of which are required for changelist creation.  # noqa: E501

        :param changelist: The changelist of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._changelist = changelist

    @property
    def check_integrity(self):
        """Gets the check_integrity of this SyncPolicyExtended.  # noqa: E501

        If true, the sync target performs cyclic redundancy checks (CRC) on the data as it is received.  # noqa: E501

        :return: The check_integrity of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._check_integrity

    @check_integrity.setter
    def check_integrity(self, check_integrity):
        """Sets the check_integrity of this SyncPolicyExtended.

        If true, the sync target performs cyclic redundancy checks (CRC) on the data as it is received.  # noqa: E501

        :param check_integrity: The check_integrity of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._check_integrity = check_integrity

    @property
    def cloud_deep_copy(self):
        """Gets the cloud_deep_copy of this SyncPolicyExtended.  # noqa: E501

        If set to deny, replicates all CloudPools smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, the job will fail. If set to force, replicates all smartlinks to the target cluster as regular files. If set to allow, SyncIQ will attempt to replicate smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, SyncIQ will replicate the smartlinks as regular files.  # noqa: E501

        :return: The cloud_deep_copy of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._cloud_deep_copy

    @cloud_deep_copy.setter
    def cloud_deep_copy(self, cloud_deep_copy):
        """Sets the cloud_deep_copy of this SyncPolicyExtended.

        If set to deny, replicates all CloudPools smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, the job will fail. If set to force, replicates all smartlinks to the target cluster as regular files. If set to allow, SyncIQ will attempt to replicate smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, SyncIQ will replicate the smartlinks as regular files.  # noqa: E501

        :param cloud_deep_copy: The cloud_deep_copy of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        allowed_values = ["deny", "allow", "force"]  # noqa: E501
        if cloud_deep_copy not in allowed_values:
            raise ValueError(
                "Invalid value for `cloud_deep_copy` ({0}), must be one of {1}"  # noqa: E501
                .format(cloud_deep_copy, allowed_values)
            )

        self._cloud_deep_copy = cloud_deep_copy

    @property
    def conflicted(self):
        """Gets the conflicted of this SyncPolicyExtended.  # noqa: E501

        NOTE: This field should not be changed without the help of PowerScale support.  If true, the most recent run of this policy encountered an error and this policy will not start any more scheduled jobs until this field is manually set back to 'false'.  # noqa: E501

        :return: The conflicted of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._conflicted

    @conflicted.setter
    def conflicted(self, conflicted):
        """Sets the conflicted of this SyncPolicyExtended.

        NOTE: This field should not be changed without the help of PowerScale support.  If true, the most recent run of this policy encountered an error and this policy will not start any more scheduled jobs until this field is manually set back to 'false'.  # noqa: E501

        :param conflicted: The conflicted of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._conflicted = conflicted

    @property
    def database_mirrored(self):
        """Gets the database_mirrored of this SyncPolicyExtended.  # noqa: E501

        If true, SyncIQ databases have been mirrored.  # noqa: E501

        :return: The database_mirrored of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._database_mirrored

    @database_mirrored.setter
    def database_mirrored(self, database_mirrored):
        """Sets the database_mirrored of this SyncPolicyExtended.

        If true, SyncIQ databases have been mirrored.  # noqa: E501

        :param database_mirrored: The database_mirrored of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._database_mirrored = database_mirrored

    @property
    def delete_quotas(self):
        """Gets the delete_quotas of this SyncPolicyExtended.  # noqa: E501

        If true, forcibly remove quotas on the target after they have been removed on the source.  # noqa: E501

        :return: The delete_quotas of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._delete_quotas

    @delete_quotas.setter
    def delete_quotas(self, delete_quotas):
        """Sets the delete_quotas of this SyncPolicyExtended.

        If true, forcibly remove quotas on the target after they have been removed on the source.  # noqa: E501

        :param delete_quotas: The delete_quotas of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._delete_quotas = delete_quotas

    @property
    def description(self):
        """Gets the description of this SyncPolicyExtended.  # noqa: E501

        User-assigned description of this sync policy.  # noqa: E501

        :return: The description of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this SyncPolicyExtended.

        User-assigned description of this sync policy.  # noqa: E501

        :param description: The description of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if description is not None and len(description) > 255:
            raise ValueError("Invalid value for `description`, length must be less than or equal to `255`")  # noqa: E501
        if description is not None and len(description) < 0:
            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501

        self._description = description

    @property
    def disable_file_split(self):
        """Gets the disable_file_split of this SyncPolicyExtended.  # noqa: E501

        NOTE: This field should not be changed without the help of PowerScale support.  If true, the 7.2+ file splitting capability will be disabled.  # noqa: E501

        :return: The disable_file_split of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._disable_file_split

    @disable_file_split.setter
    def disable_file_split(self, disable_file_split):
        """Sets the disable_file_split of this SyncPolicyExtended.

        NOTE: This field should not be changed without the help of PowerScale support.  If true, the 7.2+ file splitting capability will be disabled.  # noqa: E501

        :param disable_file_split: The disable_file_split of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._disable_file_split = disable_file_split

    @property
    def disable_fofb(self):
        """Gets the disable_fofb of this SyncPolicyExtended.  # noqa: E501

        NOTE: This field should not be changed without the help of PowerScale support.  Enable/disable sync failover/failback.  # noqa: E501

        :return: The disable_fofb of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._disable_fofb

    @disable_fofb.setter
    def disable_fofb(self, disable_fofb):
        """Sets the disable_fofb of this SyncPolicyExtended.

        NOTE: This field should not be changed without the help of PowerScale support.  Enable/disable sync failover/failback.  # noqa: E501

        :param disable_fofb: The disable_fofb of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._disable_fofb = disable_fofb

    @property
    def disable_quota_tmp_dir(self):
        """Gets the disable_quota_tmp_dir of this SyncPolicyExtended.  # noqa: E501

        If set to true, SyncIQ will not create temporary quota directories to aid in replication to target paths which contain quotas.  # noqa: E501

        :return: The disable_quota_tmp_dir of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._disable_quota_tmp_dir

    @disable_quota_tmp_dir.setter
    def disable_quota_tmp_dir(self, disable_quota_tmp_dir):
        """Sets the disable_quota_tmp_dir of this SyncPolicyExtended.

        If set to true, SyncIQ will not create temporary quota directories to aid in replication to target paths which contain quotas.  # noqa: E501

        :param disable_quota_tmp_dir: The disable_quota_tmp_dir of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._disable_quota_tmp_dir = disable_quota_tmp_dir

    @property
    def disable_stf(self):
        """Gets the disable_stf of this SyncPolicyExtended.  # noqa: E501

        NOTE: This field should not be changed without the help of PowerScale support.  Enable/disable the 6.5+ STF based data transfer and uses only treewalk.  # noqa: E501

        :return: The disable_stf of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._disable_stf

    @disable_stf.setter
    def disable_stf(self, disable_stf):
        """Sets the disable_stf of this SyncPolicyExtended.

        NOTE: This field should not be changed without the help of PowerScale support.  Enable/disable the 6.5+ STF based data transfer and uses only treewalk.  # noqa: E501

        :param disable_stf: The disable_stf of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._disable_stf = disable_stf

    @property
    def enable_hash_tmpdir(self):
        """Gets the enable_hash_tmpdir of this SyncPolicyExtended.  # noqa: E501

        If true, syncs will use temporary working directory subdirectories to reduce lock contention.  # noqa: E501

        :return: The enable_hash_tmpdir of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._enable_hash_tmpdir

    @enable_hash_tmpdir.setter
    def enable_hash_tmpdir(self, enable_hash_tmpdir):
        """Sets the enable_hash_tmpdir of this SyncPolicyExtended.

        If true, syncs will use temporary working directory subdirectories to reduce lock contention.  # noqa: E501

        :param enable_hash_tmpdir: The enable_hash_tmpdir of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._enable_hash_tmpdir = enable_hash_tmpdir

    @property
    def enabled(self):
        """Gets the enabled of this SyncPolicyExtended.  # noqa: E501

        If true, jobs will be automatically run based on this policy, according to its schedule.  # noqa: E501

        :return: The enabled of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._enabled

    @enabled.setter
    def enabled(self, enabled):
        """Sets the enabled of this SyncPolicyExtended.

        If true, jobs will be automatically run based on this policy, according to its schedule.  # noqa: E501

        :param enabled: The enabled of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """
        if enabled is None:
            raise ValueError("Invalid value for `enabled`, must not be `None`")  # noqa: E501

        self._enabled = enabled

    @property
    def encrypted(self):
        """Gets the encrypted of this SyncPolicyExtended.  # noqa: E501

        If true, syncs will be encrypted.  # noqa: E501

        :return: The encrypted of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._encrypted

    @encrypted.setter
    def encrypted(self, encrypted):
        """Sets the encrypted of this SyncPolicyExtended.

        If true, syncs will be encrypted.  # noqa: E501

        :param encrypted: The encrypted of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._encrypted = encrypted

    @property
    def encryption_cipher_list(self):
        """Gets the encryption_cipher_list of this SyncPolicyExtended.  # noqa: E501

        The cipher list being used with encryption. For SyncIQ targets, this list serves as a list of supported ciphers. For SyncIQ sources, the list of ciphers will be attempted to be used in order.  # noqa: E501

        :return: The encryption_cipher_list of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._encryption_cipher_list

    @encryption_cipher_list.setter
    def encryption_cipher_list(self, encryption_cipher_list):
        """Sets the encryption_cipher_list of this SyncPolicyExtended.

        The cipher list being used with encryption. For SyncIQ targets, this list serves as a list of supported ciphers. For SyncIQ sources, the list of ciphers will be attempted to be used in order.  # noqa: E501

        :param encryption_cipher_list: The encryption_cipher_list of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if encryption_cipher_list is not None and len(encryption_cipher_list) > 255:
            raise ValueError("Invalid value for `encryption_cipher_list`, length must be less than or equal to `255`")  # noqa: E501
        if encryption_cipher_list is not None and len(encryption_cipher_list) < 0:
            raise ValueError("Invalid value for `encryption_cipher_list`, length must be greater than or equal to `0`")  # noqa: E501

        self._encryption_cipher_list = encryption_cipher_list

    @property
    def expected_dataloss(self):
        """Gets the expected_dataloss of this SyncPolicyExtended.  # noqa: E501

        NOTE: This field should not be changed without the help of PowerScale support.  Continue sending files even with the corrupted filesystem.  # noqa: E501

        :return: The expected_dataloss of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._expected_dataloss

    @expected_dataloss.setter
    def expected_dataloss(self, expected_dataloss):
        """Sets the expected_dataloss of this SyncPolicyExtended.

        NOTE: This field should not be changed without the help of PowerScale support.  Continue sending files even with the corrupted filesystem.  # noqa: E501

        :param expected_dataloss: The expected_dataloss of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._expected_dataloss = expected_dataloss

    @property
    def file_matching_pattern(self):
        """Gets the file_matching_pattern of this SyncPolicyExtended.  # noqa: E501

        A file matching pattern, organized as an OR'ed set of AND'ed file criteria, for example ((a AND b) OR (x AND y)) used to define a set of files with specific properties.  Policies of type 'sync' cannot use 'path' or time criteria in their matching patterns, but policies of type 'copy' can use all listed criteria.  # noqa: E501

        :return: The file_matching_pattern of this SyncPolicyExtended.  # noqa: E501
        :rtype: SyncPolicyFileMatchingPattern
        """
        return self._file_matching_pattern

    @file_matching_pattern.setter
    def file_matching_pattern(self, file_matching_pattern):
        """Sets the file_matching_pattern of this SyncPolicyExtended.

        A file matching pattern, organized as an OR'ed set of AND'ed file criteria, for example ((a AND b) OR (x AND y)) used to define a set of files with specific properties.  Policies of type 'sync' cannot use 'path' or time criteria in their matching patterns, but policies of type 'copy' can use all listed criteria.  # noqa: E501

        :param file_matching_pattern: The file_matching_pattern of this SyncPolicyExtended.  # noqa: E501
        :type: SyncPolicyFileMatchingPattern
        """

        self._file_matching_pattern = file_matching_pattern

    @property
    def force_interface(self):
        """Gets the force_interface of this SyncPolicyExtended.  # noqa: E501

        NOTE: This field should not be changed without the help of PowerScale support.  Determines whether data is sent only through the subnet and pool specified in the \"source_network\" field. This option can be useful if there are multiple interfaces for the given source subnet.  If you enable this option, the net.inet.ip.choose_ifa_by_ipsrc sysctl should be set.  # noqa: E501

        :return: The force_interface of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._force_interface

    @force_interface.setter
    def force_interface(self, force_interface):
        """Sets the force_interface of this SyncPolicyExtended.

        NOTE: This field should not be changed without the help of PowerScale support.  Determines whether data is sent only through the subnet and pool specified in the \"source_network\" field. This option can be useful if there are multiple interfaces for the given source subnet.  If you enable this option, the net.inet.ip.choose_ifa_by_ipsrc sysctl should be set.  # noqa: E501

        :param force_interface: The force_interface of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._force_interface = force_interface

    @property
    def has_sync_state(self):
        """Gets the has_sync_state of this SyncPolicyExtended.  # noqa: E501

        This field is false if the policy is in its initial sync state and true otherwise.  Setting this field to false will reset the policy's sync state.  # noqa: E501

        :return: The has_sync_state of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._has_sync_state

    @has_sync_state.setter
    def has_sync_state(self, has_sync_state):
        """Sets the has_sync_state of this SyncPolicyExtended.

        This field is false if the policy is in its initial sync state and true otherwise.  Setting this field to false will reset the policy's sync state.  # noqa: E501

        :param has_sync_state: The has_sync_state of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._has_sync_state = has_sync_state

    @property
    def id(self):
        """Gets the id of this SyncPolicyExtended.  # noqa: E501

        The system ID given to this sync policy.  # noqa: E501

        :return: The id of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this SyncPolicyExtended.

        The system ID given to this sync policy.  # noqa: E501

        :param id: The id of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501
        if id is not None and len(id) > 255:
            raise ValueError("Invalid value for `id`, length must be less than or equal to `255`")  # noqa: E501
        if id is not None and len(id) < 1:
            raise ValueError("Invalid value for `id`, length must be greater than or equal to `1`")  # noqa: E501

        self._id = id

    @property
    def ignore_recursive_quota(self):
        """Gets the ignore_recursive_quota of this SyncPolicyExtended.  # noqa: E501

        If set to true, SyncIQ will not check the recursive quota in target paths to aid in replication to target paths which contain no quota but target cluster has lots of quotas.  # noqa: E501

        :return: The ignore_recursive_quota of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._ignore_recursive_quota

    @ignore_recursive_quota.setter
    def ignore_recursive_quota(self, ignore_recursive_quota):
        """Sets the ignore_recursive_quota of this SyncPolicyExtended.

        If set to true, SyncIQ will not check the recursive quota in target paths to aid in replication to target paths which contain no quota but target cluster has lots of quotas.  # noqa: E501

        :param ignore_recursive_quota: The ignore_recursive_quota of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._ignore_recursive_quota = ignore_recursive_quota

    @property
    def job_delay(self):
        """Gets the job_delay of this SyncPolicyExtended.  # noqa: E501

        If --schedule is set to When-Source-Modified, the duration to wait after a modification is made before starting a job (default is 0 seconds).  # noqa: E501

        :return: The job_delay of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._job_delay

    @job_delay.setter
    def job_delay(self, job_delay):
        """Sets the job_delay of this SyncPolicyExtended.

        If --schedule is set to When-Source-Modified, the duration to wait after a modification is made before starting a job (default is 0 seconds).  # noqa: E501

        :param job_delay: The job_delay of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if job_delay is not None and job_delay > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `job_delay`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if job_delay is not None and job_delay < 0:  # noqa: E501
            raise ValueError("Invalid value for `job_delay`, must be a value greater than or equal to `0`")  # noqa: E501

        self._job_delay = job_delay

    @property
    def last_job_state(self):
        """Gets the last_job_state of this SyncPolicyExtended.  # noqa: E501

        This is the state of the most recent job for this policy.  # noqa: E501

        :return: The last_job_state of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._last_job_state

    @last_job_state.setter
    def last_job_state(self, last_job_state):
        """Sets the last_job_state of this SyncPolicyExtended.

        This is the state of the most recent job for this policy.  # noqa: E501

        :param last_job_state: The last_job_state of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if last_job_state is not None and len(last_job_state) > 255:
            raise ValueError("Invalid value for `last_job_state`, length must be less than or equal to `255`")  # noqa: E501
        if last_job_state is not None and len(last_job_state) < 1:
            raise ValueError("Invalid value for `last_job_state`, length must be greater than or equal to `1`")  # noqa: E501

        self._last_job_state = last_job_state

    @property
    def last_started(self):
        """Gets the last_started of this SyncPolicyExtended.  # noqa: E501

        The most recent time a job was started for this policy.  Value is null if the policy has never been run.  # noqa: E501

        :return: The last_started of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._last_started

    @last_started.setter
    def last_started(self, last_started):
        """Sets the last_started of this SyncPolicyExtended.

        The most recent time a job was started for this policy.  Value is null if the policy has never been run.  # noqa: E501

        :param last_started: The last_started of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if last_started is not None and last_started > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `last_started`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if last_started is not None and last_started < 0:  # noqa: E501
            raise ValueError("Invalid value for `last_started`, must be a value greater than or equal to `0`")  # noqa: E501

        self._last_started = last_started

    @property
    def last_success(self):
        """Gets the last_success of this SyncPolicyExtended.  # noqa: E501

        Timestamp of last known successfully completed synchronization.  Value is null if the policy has never completed successfully.  # noqa: E501

        :return: The last_success of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._last_success

    @last_success.setter
    def last_success(self, last_success):
        """Sets the last_success of this SyncPolicyExtended.

        Timestamp of last known successfully completed synchronization.  Value is null if the policy has never completed successfully.  # noqa: E501

        :param last_success: The last_success of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if last_success is not None and last_success > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `last_success`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if last_success is not None and last_success < 0:  # noqa: E501
            raise ValueError("Invalid value for `last_success`, must be a value greater than or equal to `0`")  # noqa: E501

        self._last_success = last_success

    @property
    def linked_service_policies(self):
        """Gets the linked_service_policies of this SyncPolicyExtended.  # noqa: E501

        A list of service replication policies that this data replication policy will be associated with.  # noqa: E501

        :return: The linked_service_policies of this SyncPolicyExtended.  # noqa: E501
        :rtype: list[str]
        """
        return self._linked_service_policies

    @linked_service_policies.setter
    def linked_service_policies(self, linked_service_policies):
        """Sets the linked_service_policies of this SyncPolicyExtended.

        A list of service replication policies that this data replication policy will be associated with.  # noqa: E501

        :param linked_service_policies: The linked_service_policies of this SyncPolicyExtended.  # noqa: E501
        :type: list[str]
        """

        self._linked_service_policies = linked_service_policies

    @property
    def log_level(self):
        """Gets the log_level of this SyncPolicyExtended.  # noqa: E501

        Severity an event must reach before it is logged.  # noqa: E501

        :return: The log_level of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._log_level

    @log_level.setter
    def log_level(self, log_level):
        """Sets the log_level of this SyncPolicyExtended.

        Severity an event must reach before it is logged.  # noqa: E501

        :param log_level: The log_level of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        allowed_values = ["fatal", "error", "notice", "info", "copy", "debug", "trace"]  # noqa: E501
        if log_level not in allowed_values:
            raise ValueError(
                "Invalid value for `log_level` ({0}), must be one of {1}"  # noqa: E501
                .format(log_level, allowed_values)
            )

        self._log_level = log_level

    @property
    def log_removed_files(self):
        """Gets the log_removed_files of this SyncPolicyExtended.  # noqa: E501

        If true, the system will log any files or directories that are deleted due to a sync.  # noqa: E501

        :return: The log_removed_files of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._log_removed_files

    @log_removed_files.setter
    def log_removed_files(self, log_removed_files):
        """Sets the log_removed_files of this SyncPolicyExtended.

        If true, the system will log any files or directories that are deleted due to a sync.  # noqa: E501

        :param log_removed_files: The log_removed_files of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._log_removed_files = log_removed_files

    @property
    def name(self):
        """Gets the name of this SyncPolicyExtended.  # noqa: E501

        User-assigned name of this sync policy.  # noqa: E501

        :return: The name of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this SyncPolicyExtended.

        User-assigned name of this sync policy.  # noqa: E501

        :param name: The name of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
        if name is not None and len(name) > 255:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `255`")  # noqa: E501
        if name is not None and len(name) < 1:
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501

        self._name = name

    @property
    def next_run(self):
        """Gets the next_run of this SyncPolicyExtended.  # noqa: E501

        This is the next time a job is scheduled to run for this policy in Unix epoch seconds.  This field is null if the job is not scheduled.  # noqa: E501

        :return: The next_run of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._next_run

    @next_run.setter
    def next_run(self, next_run):
        """Sets the next_run of this SyncPolicyExtended.

        This is the next time a job is scheduled to run for this policy in Unix epoch seconds.  This field is null if the job is not scheduled.  # noqa: E501

        :param next_run: The next_run of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if next_run is not None and next_run > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `next_run`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if next_run is not None and next_run < 0:  # noqa: E501
            raise ValueError("Invalid value for `next_run`, must be a value greater than or equal to `0`")  # noqa: E501

        self._next_run = next_run

    @property
    def ocsp_address(self):
        """Gets the ocsp_address of this SyncPolicyExtended.  # noqa: E501

        The address of the OCSP responder to which to connect.  # noqa: E501

        :return: The ocsp_address of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._ocsp_address

    @ocsp_address.setter
    def ocsp_address(self, ocsp_address):
        """Sets the ocsp_address of this SyncPolicyExtended.

        The address of the OCSP responder to which to connect.  # noqa: E501

        :param ocsp_address: The ocsp_address of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if ocsp_address is not None and len(ocsp_address) > 255:
            raise ValueError("Invalid value for `ocsp_address`, length must be less than or equal to `255`")  # noqa: E501
        if ocsp_address is not None and len(ocsp_address) < 0:
            raise ValueError("Invalid value for `ocsp_address`, length must be greater than or equal to `0`")  # noqa: E501

        self._ocsp_address = ocsp_address

    @property
    def ocsp_issuer_certificate_id(self):
        """Gets the ocsp_issuer_certificate_id of this SyncPolicyExtended.  # noqa: E501

        The ID of the certificate authority that issued the certificate whose revocation status is being checked.  # noqa: E501

        :return: The ocsp_issuer_certificate_id of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._ocsp_issuer_certificate_id

    @ocsp_issuer_certificate_id.setter
    def ocsp_issuer_certificate_id(self, ocsp_issuer_certificate_id):
        """Sets the ocsp_issuer_certificate_id of this SyncPolicyExtended.

        The ID of the certificate authority that issued the certificate whose revocation status is being checked.  # noqa: E501

        :param ocsp_issuer_certificate_id: The ocsp_issuer_certificate_id of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if ocsp_issuer_certificate_id is not None and len(ocsp_issuer_certificate_id) > 255:
            raise ValueError("Invalid value for `ocsp_issuer_certificate_id`, length must be less than or equal to `255`")  # noqa: E501
        if ocsp_issuer_certificate_id is not None and len(ocsp_issuer_certificate_id) < 0:
            raise ValueError("Invalid value for `ocsp_issuer_certificate_id`, length must be greater than or equal to `0`")  # noqa: E501

        self._ocsp_issuer_certificate_id = ocsp_issuer_certificate_id

    @property
    def password_set(self):
        """Gets the password_set of this SyncPolicyExtended.  # noqa: E501

        Indicates if a password is set for accessing the target cluster. Password value is not shown with GET.  # noqa: E501

        :return: The password_set of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._password_set

    @password_set.setter
    def password_set(self, password_set):
        """Sets the password_set of this SyncPolicyExtended.

        Indicates if a password is set for accessing the target cluster. Password value is not shown with GET.  # noqa: E501

        :param password_set: The password_set of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._password_set = password_set

    @property
    def priority(self):
        """Gets the priority of this SyncPolicyExtended.  # noqa: E501

        Determines the priority level of a policy. Policies with higher priority will have precedence to run over lower priority policies. Valid range is [0, 1]. Default is 0.  # noqa: E501

        :return: The priority of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._priority

    @priority.setter
    def priority(self, priority):
        """Sets the priority of this SyncPolicyExtended.

        Determines the priority level of a policy. Policies with higher priority will have precedence to run over lower priority policies. Valid range is [0, 1]. Default is 0.  # noqa: E501

        :param priority: The priority of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if priority is not None and priority > 1:  # noqa: E501
            raise ValueError("Invalid value for `priority`, must be a value less than or equal to `1`")  # noqa: E501
        if priority is not None and priority < 0:  # noqa: E501
            raise ValueError("Invalid value for `priority`, must be a value greater than or equal to `0`")  # noqa: E501

        self._priority = priority

    @property
    def report_max_age(self):
        """Gets the report_max_age of this SyncPolicyExtended.  # noqa: E501

        Length of time (in seconds) a policy report will be stored.  # noqa: E501

        :return: The report_max_age of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._report_max_age

    @report_max_age.setter
    def report_max_age(self, report_max_age):
        """Sets the report_max_age of this SyncPolicyExtended.

        Length of time (in seconds) a policy report will be stored.  # noqa: E501

        :param report_max_age: The report_max_age of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if report_max_age is not None and report_max_age > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `report_max_age`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if report_max_age is not None and report_max_age < 0:  # noqa: E501
            raise ValueError("Invalid value for `report_max_age`, must be a value greater than or equal to `0`")  # noqa: E501

        self._report_max_age = report_max_age

    @property
    def report_max_count(self):
        """Gets the report_max_count of this SyncPolicyExtended.  # noqa: E501

        Maximum number of policy reports that will be stored on the system.  # noqa: E501

        :return: The report_max_count of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._report_max_count

    @report_max_count.setter
    def report_max_count(self, report_max_count):
        """Sets the report_max_count of this SyncPolicyExtended.

        Maximum number of policy reports that will be stored on the system.  # noqa: E501

        :param report_max_count: The report_max_count of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if report_max_count is not None and report_max_count > 2000:  # noqa: E501
            raise ValueError("Invalid value for `report_max_count`, must be a value less than or equal to `2000`")  # noqa: E501
        if report_max_count is not None and report_max_count < 1:  # noqa: E501
            raise ValueError("Invalid value for `report_max_count`, must be a value greater than or equal to `1`")  # noqa: E501

        self._report_max_count = report_max_count

    @property
    def restrict_target_network(self):
        """Gets the restrict_target_network of this SyncPolicyExtended.  # noqa: E501

        If you specify true, and you specify a SmartConnect zone in the \"target_host\" field, replication policies will connect only to nodes in the specified SmartConnect zone.  If you specify false, replication policies are not restricted to specific nodes on the target cluster.  # noqa: E501

        :return: The restrict_target_network of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._restrict_target_network

    @restrict_target_network.setter
    def restrict_target_network(self, restrict_target_network):
        """Sets the restrict_target_network of this SyncPolicyExtended.

        If you specify true, and you specify a SmartConnect zone in the \"target_host\" field, replication policies will connect only to nodes in the specified SmartConnect zone.  If you specify false, replication policies are not restricted to specific nodes on the target cluster.  # noqa: E501

        :param restrict_target_network: The restrict_target_network of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._restrict_target_network = restrict_target_network

    @property
    def rpo_alert(self):
        """Gets the rpo_alert of this SyncPolicyExtended.  # noqa: E501

        If --schedule is set to a time/date, an alert is created if the specified RPO for this policy is exceeded. The default value is 0, which will not generate RPO alerts.  # noqa: E501

        :return: The rpo_alert of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._rpo_alert

    @rpo_alert.setter
    def rpo_alert(self, rpo_alert):
        """Sets the rpo_alert of this SyncPolicyExtended.

        If --schedule is set to a time/date, an alert is created if the specified RPO for this policy is exceeded. The default value is 0, which will not generate RPO alerts.  # noqa: E501

        :param rpo_alert: The rpo_alert of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if rpo_alert is not None and rpo_alert > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `rpo_alert`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if rpo_alert is not None and rpo_alert < 0:  # noqa: E501
            raise ValueError("Invalid value for `rpo_alert`, must be a value greater than or equal to `0`")  # noqa: E501

        self._rpo_alert = rpo_alert

    @property
    def schedule(self):
        """Gets the schedule of this SyncPolicyExtended.  # noqa: E501

        The schedule on which new jobs will be run for this policy.  # noqa: E501

        :return: The schedule of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._schedule

    @schedule.setter
    def schedule(self, schedule):
        """Sets the schedule of this SyncPolicyExtended.

        The schedule on which new jobs will be run for this policy.  # noqa: E501

        :param schedule: The schedule of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if schedule is None:
            raise ValueError("Invalid value for `schedule`, must not be `None`")  # noqa: E501
        if schedule is not None and len(schedule) > 255:
            raise ValueError("Invalid value for `schedule`, length must be less than or equal to `255`")  # noqa: E501
        if schedule is not None and len(schedule) < 0:
            raise ValueError("Invalid value for `schedule`, length must be greater than or equal to `0`")  # noqa: E501

        self._schedule = schedule

    @property
    def service_policy(self):
        """Gets the service_policy of this SyncPolicyExtended.  # noqa: E501

        If true, this is a service replication policy.  # noqa: E501

        :return: The service_policy of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._service_policy

    @service_policy.setter
    def service_policy(self, service_policy):
        """Sets the service_policy of this SyncPolicyExtended.

        If true, this is a service replication policy.  # noqa: E501

        :param service_policy: The service_policy of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._service_policy = service_policy

    @property
    def skip_lookup(self):
        """Gets the skip_lookup of this SyncPolicyExtended.  # noqa: E501

        Skip DNS lookup of target IPs.  # noqa: E501

        :return: The skip_lookup of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._skip_lookup

    @skip_lookup.setter
    def skip_lookup(self, skip_lookup):
        """Sets the skip_lookup of this SyncPolicyExtended.

        Skip DNS lookup of target IPs.  # noqa: E501

        :param skip_lookup: The skip_lookup of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._skip_lookup = skip_lookup

    @property
    def skip_when_source_unmodified(self):
        """Gets the skip_when_source_unmodified of this SyncPolicyExtended.  # noqa: E501

        If true and --schedule is set to a time/date, the policy will not run if no changes have been made to the contents of the source directory since the last job successfully completed.  # noqa: E501

        :return: The skip_when_source_unmodified of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._skip_when_source_unmodified

    @skip_when_source_unmodified.setter
    def skip_when_source_unmodified(self, skip_when_source_unmodified):
        """Sets the skip_when_source_unmodified of this SyncPolicyExtended.

        If true and --schedule is set to a time/date, the policy will not run if no changes have been made to the contents of the source directory since the last job successfully completed.  # noqa: E501

        :param skip_when_source_unmodified: The skip_when_source_unmodified of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._skip_when_source_unmodified = skip_when_source_unmodified

    @property
    def snapshot_sync_existing(self):
        """Gets the snapshot_sync_existing of this SyncPolicyExtended.  # noqa: E501

        If true, snapshot-triggered syncs will include snapshots taken before policy creation time (requires --schedule when-snapshot-taken).  # noqa: E501

        :return: The snapshot_sync_existing of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._snapshot_sync_existing

    @snapshot_sync_existing.setter
    def snapshot_sync_existing(self, snapshot_sync_existing):
        """Sets the snapshot_sync_existing of this SyncPolicyExtended.

        If true, snapshot-triggered syncs will include snapshots taken before policy creation time (requires --schedule when-snapshot-taken).  # noqa: E501

        :param snapshot_sync_existing: The snapshot_sync_existing of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._snapshot_sync_existing = snapshot_sync_existing

    @property
    def snapshot_sync_pattern(self):
        """Gets the snapshot_sync_pattern of this SyncPolicyExtended.  # noqa: E501

        The naming pattern that a snapshot must match to trigger a sync when the schedule is when-snapshot-taken (default is \"*\").  # noqa: E501

        :return: The snapshot_sync_pattern of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._snapshot_sync_pattern

    @snapshot_sync_pattern.setter
    def snapshot_sync_pattern(self, snapshot_sync_pattern):
        """Sets the snapshot_sync_pattern of this SyncPolicyExtended.

        The naming pattern that a snapshot must match to trigger a sync when the schedule is when-snapshot-taken (default is \"*\").  # noqa: E501

        :param snapshot_sync_pattern: The snapshot_sync_pattern of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if snapshot_sync_pattern is not None and len(snapshot_sync_pattern) > 255:
            raise ValueError("Invalid value for `snapshot_sync_pattern`, length must be less than or equal to `255`")  # noqa: E501
        if snapshot_sync_pattern is not None and len(snapshot_sync_pattern) < 1:
            raise ValueError("Invalid value for `snapshot_sync_pattern`, length must be greater than or equal to `1`")  # noqa: E501

        self._snapshot_sync_pattern = snapshot_sync_pattern

    @property
    def source_certificate_id(self):
        """Gets the source_certificate_id of this SyncPolicyExtended.  # noqa: E501

        The ID of the source cluster certificate being used for encryption.  # noqa: E501

        :return: The source_certificate_id of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._source_certificate_id

    @source_certificate_id.setter
    def source_certificate_id(self, source_certificate_id):
        """Sets the source_certificate_id of this SyncPolicyExtended.

        The ID of the source cluster certificate being used for encryption.  # noqa: E501

        :param source_certificate_id: The source_certificate_id of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if source_certificate_id is not None and len(source_certificate_id) > 255:
            raise ValueError("Invalid value for `source_certificate_id`, length must be less than or equal to `255`")  # noqa: E501
        if source_certificate_id is not None and len(source_certificate_id) < 0:
            raise ValueError("Invalid value for `source_certificate_id`, length must be greater than or equal to `0`")  # noqa: E501

        self._source_certificate_id = source_certificate_id

    @property
    def source_domain_marked(self):
        """Gets the source_domain_marked of this SyncPolicyExtended.  # noqa: E501

        If true, the source root path has been domain marked with a SyncIQ domain.  # noqa: E501

        :return: The source_domain_marked of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._source_domain_marked

    @source_domain_marked.setter
    def source_domain_marked(self, source_domain_marked):
        """Sets the source_domain_marked of this SyncPolicyExtended.

        If true, the source root path has been domain marked with a SyncIQ domain.  # noqa: E501

        :param source_domain_marked: The source_domain_marked of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._source_domain_marked = source_domain_marked

    @property
    def source_exclude_directories(self):
        """Gets the source_exclude_directories of this SyncPolicyExtended.  # noqa: E501

        Directories that will be excluded from the sync.  Modifying this field will result in a full synchronization of all data.  # noqa: E501

        :return: The source_exclude_directories of this SyncPolicyExtended.  # noqa: E501
        :rtype: list[str]
        """
        return self._source_exclude_directories

    @source_exclude_directories.setter
    def source_exclude_directories(self, source_exclude_directories):
        """Sets the source_exclude_directories of this SyncPolicyExtended.

        Directories that will be excluded from the sync.  Modifying this field will result in a full synchronization of all data.  # noqa: E501

        :param source_exclude_directories: The source_exclude_directories of this SyncPolicyExtended.  # noqa: E501
        :type: list[str]
        """

        self._source_exclude_directories = source_exclude_directories

    @property
    def source_include_directories(self):
        """Gets the source_include_directories of this SyncPolicyExtended.  # noqa: E501

        Directories that will be included in the sync.  Modifying this field will result in a full synchronization of all data.  # noqa: E501

        :return: The source_include_directories of this SyncPolicyExtended.  # noqa: E501
        :rtype: list[str]
        """
        return self._source_include_directories

    @source_include_directories.setter
    def source_include_directories(self, source_include_directories):
        """Sets the source_include_directories of this SyncPolicyExtended.

        Directories that will be included in the sync.  Modifying this field will result in a full synchronization of all data.  # noqa: E501

        :param source_include_directories: The source_include_directories of this SyncPolicyExtended.  # noqa: E501
        :type: list[str]
        """

        self._source_include_directories = source_include_directories

    @property
    def source_network(self):
        """Gets the source_network of this SyncPolicyExtended.  # noqa: E501

        Restricts replication policies on the local cluster to running on the specified subnet and pool.  # noqa: E501

        :return: The source_network of this SyncPolicyExtended.  # noqa: E501
        :rtype: SyncPolicySourceNetwork
        """
        return self._source_network

    @source_network.setter
    def source_network(self, source_network):
        """Sets the source_network of this SyncPolicyExtended.

        Restricts replication policies on the local cluster to running on the specified subnet and pool.  # noqa: E501

        :param source_network: The source_network of this SyncPolicyExtended.  # noqa: E501
        :type: SyncPolicySourceNetwork
        """

        self._source_network = source_network

    @property
    def source_root_path(self):
        """Gets the source_root_path of this SyncPolicyExtended.  # noqa: E501

        The root directory on the source cluster the files will be synced from.  Modifying this field will result in a full synchronization of all data.  # noqa: E501

        :return: The source_root_path of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._source_root_path

    @source_root_path.setter
    def source_root_path(self, source_root_path):
        """Sets the source_root_path of this SyncPolicyExtended.

        The root directory on the source cluster the files will be synced from.  Modifying this field will result in a full synchronization of all data.  # noqa: E501

        :param source_root_path: The source_root_path of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if source_root_path is None:
            raise ValueError("Invalid value for `source_root_path`, must not be `None`")  # noqa: E501
        if source_root_path is not None and len(source_root_path) > 4096:
            raise ValueError("Invalid value for `source_root_path`, length must be less than or equal to `4096`")  # noqa: E501
        if source_root_path is not None and len(source_root_path) < 1:
            raise ValueError("Invalid value for `source_root_path`, length must be greater than or equal to `1`")  # noqa: E501

        self._source_root_path = source_root_path

    @property
    def source_snapshot_archive(self):
        """Gets the source_snapshot_archive of this SyncPolicyExtended.  # noqa: E501

        If true, archival snapshots of the source data will be taken on the source cluster before a sync.  # noqa: E501

        :return: The source_snapshot_archive of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._source_snapshot_archive

    @source_snapshot_archive.setter
    def source_snapshot_archive(self, source_snapshot_archive):
        """Sets the source_snapshot_archive of this SyncPolicyExtended.

        If true, archival snapshots of the source data will be taken on the source cluster before a sync.  # noqa: E501

        :param source_snapshot_archive: The source_snapshot_archive of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._source_snapshot_archive = source_snapshot_archive

    @property
    def source_snapshot_expiration(self):
        """Gets the source_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501

        The length of time in seconds to keep snapshots on the source cluster.  # noqa: E501

        :return: The source_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._source_snapshot_expiration

    @source_snapshot_expiration.setter
    def source_snapshot_expiration(self, source_snapshot_expiration):
        """Sets the source_snapshot_expiration of this SyncPolicyExtended.

        The length of time in seconds to keep snapshots on the source cluster.  # noqa: E501

        :param source_snapshot_expiration: The source_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if source_snapshot_expiration is not None and source_snapshot_expiration > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `source_snapshot_expiration`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if source_snapshot_expiration is not None and source_snapshot_expiration < 0:  # noqa: E501
            raise ValueError("Invalid value for `source_snapshot_expiration`, must be a value greater than or equal to `0`")  # noqa: E501

        self._source_snapshot_expiration = source_snapshot_expiration

    @property
    def source_snapshot_pattern(self):
        """Gets the source_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501

        The name pattern for snapshots taken on the source cluster before a sync.  # noqa: E501

        :return: The source_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._source_snapshot_pattern

    @source_snapshot_pattern.setter
    def source_snapshot_pattern(self, source_snapshot_pattern):
        """Sets the source_snapshot_pattern of this SyncPolicyExtended.

        The name pattern for snapshots taken on the source cluster before a sync.  # noqa: E501

        :param source_snapshot_pattern: The source_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if source_snapshot_pattern is not None and len(source_snapshot_pattern) > 255:
            raise ValueError("Invalid value for `source_snapshot_pattern`, length must be less than or equal to `255`")  # noqa: E501
        if source_snapshot_pattern is not None and len(source_snapshot_pattern) < 0:
            raise ValueError("Invalid value for `source_snapshot_pattern`, length must be greater than or equal to `0`")  # noqa: E501

        self._source_snapshot_pattern = source_snapshot_pattern

    @property
    def sync_existing_snapshot_expiration(self):
        """Gets the sync_existing_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501

        If set to true, the expire duration for target archival snapshot is the remaining expire duration of source snapshot, requires --sync-existing-snapshot=true  # noqa: E501

        :return: The sync_existing_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._sync_existing_snapshot_expiration

    @sync_existing_snapshot_expiration.setter
    def sync_existing_snapshot_expiration(self, sync_existing_snapshot_expiration):
        """Sets the sync_existing_snapshot_expiration of this SyncPolicyExtended.

        If set to true, the expire duration for target archival snapshot is the remaining expire duration of source snapshot, requires --sync-existing-snapshot=true  # noqa: E501

        :param sync_existing_snapshot_expiration: The sync_existing_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._sync_existing_snapshot_expiration = sync_existing_snapshot_expiration

    @property
    def sync_existing_target_snapshot_pattern(self):
        """Gets the sync_existing_target_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501

        The naming pattern for snapshot on the destination cluster when --sync-existing-snapshot is true  # noqa: E501

        :return: The sync_existing_target_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._sync_existing_target_snapshot_pattern

    @sync_existing_target_snapshot_pattern.setter
    def sync_existing_target_snapshot_pattern(self, sync_existing_target_snapshot_pattern):
        """Sets the sync_existing_target_snapshot_pattern of this SyncPolicyExtended.

        The naming pattern for snapshot on the destination cluster when --sync-existing-snapshot is true  # noqa: E501

        :param sync_existing_target_snapshot_pattern: The sync_existing_target_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if sync_existing_target_snapshot_pattern is not None and len(sync_existing_target_snapshot_pattern) > 255:
            raise ValueError("Invalid value for `sync_existing_target_snapshot_pattern`, length must be less than or equal to `255`")  # noqa: E501
        if sync_existing_target_snapshot_pattern is not None and len(sync_existing_target_snapshot_pattern) < 0:
            raise ValueError("Invalid value for `sync_existing_target_snapshot_pattern`, length must be greater than or equal to `0`")  # noqa: E501

        self._sync_existing_target_snapshot_pattern = sync_existing_target_snapshot_pattern

    @property
    def target_certificate_id(self):
        """Gets the target_certificate_id of this SyncPolicyExtended.  # noqa: E501

        The ID of the target cluster certificate being used for encryption.  # noqa: E501

        :return: The target_certificate_id of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._target_certificate_id

    @target_certificate_id.setter
    def target_certificate_id(self, target_certificate_id):
        """Sets the target_certificate_id of this SyncPolicyExtended.

        The ID of the target cluster certificate being used for encryption.  # noqa: E501

        :param target_certificate_id: The target_certificate_id of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if target_certificate_id is not None and len(target_certificate_id) > 255:
            raise ValueError("Invalid value for `target_certificate_id`, length must be less than or equal to `255`")  # noqa: E501
        if target_certificate_id is not None and len(target_certificate_id) < 0:
            raise ValueError("Invalid value for `target_certificate_id`, length must be greater than or equal to `0`")  # noqa: E501

        self._target_certificate_id = target_certificate_id

    @property
    def target_compare_initial_sync(self):
        """Gets the target_compare_initial_sync of this SyncPolicyExtended.  # noqa: E501

        If true, the target creates diffs against the original sync.  # noqa: E501

        :return: The target_compare_initial_sync of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._target_compare_initial_sync

    @target_compare_initial_sync.setter
    def target_compare_initial_sync(self, target_compare_initial_sync):
        """Sets the target_compare_initial_sync of this SyncPolicyExtended.

        If true, the target creates diffs against the original sync.  # noqa: E501

        :param target_compare_initial_sync: The target_compare_initial_sync of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._target_compare_initial_sync = target_compare_initial_sync

    @property
    def target_detect_modifications(self):
        """Gets the target_detect_modifications of this SyncPolicyExtended.  # noqa: E501

        If true, target cluster will detect if files have been changed on the target by legacy tree walk syncs.  # noqa: E501

        :return: The target_detect_modifications of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._target_detect_modifications

    @target_detect_modifications.setter
    def target_detect_modifications(self, target_detect_modifications):
        """Sets the target_detect_modifications of this SyncPolicyExtended.

        If true, target cluster will detect if files have been changed on the target by legacy tree walk syncs.  # noqa: E501

        :param target_detect_modifications: The target_detect_modifications of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._target_detect_modifications = target_detect_modifications

    @property
    def target_host(self):
        """Gets the target_host of this SyncPolicyExtended.  # noqa: E501

        Hostname or IP address of sync target cluster.  Modifying the target cluster host can result in the policy being unrunnable if the new target does not match the current target association.  # noqa: E501

        :return: The target_host of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._target_host

    @target_host.setter
    def target_host(self, target_host):
        """Sets the target_host of this SyncPolicyExtended.

        Hostname or IP address of sync target cluster.  Modifying the target cluster host can result in the policy being unrunnable if the new target does not match the current target association.  # noqa: E501

        :param target_host: The target_host of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if target_host is None:
            raise ValueError("Invalid value for `target_host`, must not be `None`")  # noqa: E501
        if target_host is not None and len(target_host) > 255:
            raise ValueError("Invalid value for `target_host`, length must be less than or equal to `255`")  # noqa: E501
        if target_host is not None and len(target_host) < 1:
            raise ValueError("Invalid value for `target_host`, length must be greater than or equal to `1`")  # noqa: E501

        self._target_host = target_host

    @property
    def target_path(self):
        """Gets the target_path of this SyncPolicyExtended.  # noqa: E501

        Absolute filesystem path on the target cluster for the sync destination.  # noqa: E501

        :return: The target_path of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._target_path

    @target_path.setter
    def target_path(self, target_path):
        """Sets the target_path of this SyncPolicyExtended.

        Absolute filesystem path on the target cluster for the sync destination.  # noqa: E501

        :param target_path: The target_path of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if target_path is None:
            raise ValueError("Invalid value for `target_path`, must not be `None`")  # noqa: E501
        if target_path is not None and len(target_path) > 4096:
            raise ValueError("Invalid value for `target_path`, length must be less than or equal to `4096`")  # noqa: E501
        if target_path is not None and len(target_path) < 1:
            raise ValueError("Invalid value for `target_path`, length must be greater than or equal to `1`")  # noqa: E501

        self._target_path = target_path

    @property
    def target_snapshot_alias(self):
        """Gets the target_snapshot_alias of this SyncPolicyExtended.  # noqa: E501

        The alias of the snapshot taken on the target cluster after the sync completes. A value of @DEFAULT will reset this field to the default creation value.  # noqa: E501

        :return: The target_snapshot_alias of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._target_snapshot_alias

    @target_snapshot_alias.setter
    def target_snapshot_alias(self, target_snapshot_alias):
        """Sets the target_snapshot_alias of this SyncPolicyExtended.

        The alias of the snapshot taken on the target cluster after the sync completes. A value of @DEFAULT will reset this field to the default creation value.  # noqa: E501

        :param target_snapshot_alias: The target_snapshot_alias of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if target_snapshot_alias is not None and len(target_snapshot_alias) > 255:
            raise ValueError("Invalid value for `target_snapshot_alias`, length must be less than or equal to `255`")  # noqa: E501
        if target_snapshot_alias is not None and len(target_snapshot_alias) < 0:
            raise ValueError("Invalid value for `target_snapshot_alias`, length must be greater than or equal to `0`")  # noqa: E501

        self._target_snapshot_alias = target_snapshot_alias

    @property
    def target_snapshot_archive(self):
        """Gets the target_snapshot_archive of this SyncPolicyExtended.  # noqa: E501

        If true, archival snapshots of the target data will be taken on the target cluster after successful sync completions.  # noqa: E501

        :return: The target_snapshot_archive of this SyncPolicyExtended.  # noqa: E501
        :rtype: bool
        """
        return self._target_snapshot_archive

    @target_snapshot_archive.setter
    def target_snapshot_archive(self, target_snapshot_archive):
        """Sets the target_snapshot_archive of this SyncPolicyExtended.

        If true, archival snapshots of the target data will be taken on the target cluster after successful sync completions.  # noqa: E501

        :param target_snapshot_archive: The target_snapshot_archive of this SyncPolicyExtended.  # noqa: E501
        :type: bool
        """

        self._target_snapshot_archive = target_snapshot_archive

    @property
    def target_snapshot_expiration(self):
        """Gets the target_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501

        The length of time in seconds to keep snapshots on the target cluster.  # noqa: E501

        :return: The target_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._target_snapshot_expiration

    @target_snapshot_expiration.setter
    def target_snapshot_expiration(self, target_snapshot_expiration):
        """Sets the target_snapshot_expiration of this SyncPolicyExtended.

        The length of time in seconds to keep snapshots on the target cluster.  # noqa: E501

        :param target_snapshot_expiration: The target_snapshot_expiration of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if target_snapshot_expiration is not None and target_snapshot_expiration > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `target_snapshot_expiration`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if target_snapshot_expiration is not None and target_snapshot_expiration < 0:  # noqa: E501
            raise ValueError("Invalid value for `target_snapshot_expiration`, must be a value greater than or equal to `0`")  # noqa: E501

        self._target_snapshot_expiration = target_snapshot_expiration

    @property
    def target_snapshot_pattern(self):
        """Gets the target_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501

        The name pattern for snapshots taken on the target cluster after the sync completes.  A value of @DEFAULT will reset this field to the default creation value.  # noqa: E501

        :return: The target_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501
        :rtype: str
        """
        return self._target_snapshot_pattern

    @target_snapshot_pattern.setter
    def target_snapshot_pattern(self, target_snapshot_pattern):
        """Sets the target_snapshot_pattern of this SyncPolicyExtended.

        The name pattern for snapshots taken on the target cluster after the sync completes.  A value of @DEFAULT will reset this field to the default creation value.  # noqa: E501

        :param target_snapshot_pattern: The target_snapshot_pattern of this SyncPolicyExtended.  # noqa: E501
        :type: str
        """
        if target_snapshot_pattern is not None and len(target_snapshot_pattern) > 255:
            raise ValueError("Invalid value for `target_snapshot_pattern`, length must be less than or equal to `255`")  # noqa: E501
        if target_snapshot_pattern is not None and len(target_snapshot_pattern) < 0:
            raise ValueError("Invalid value for `target_snapshot_pattern`, length must be greater than or equal to `0`")  # noqa: E501

        self._target_snapshot_pattern = target_snapshot_pattern

    @property
    def workers_per_node(self):
        """Gets the workers_per_node of this SyncPolicyExtended.  # noqa: E501

        The number of worker threads on a node performing a sync.  # noqa: E501

        :return: The workers_per_node of this SyncPolicyExtended.  # noqa: E501
        :rtype: int
        """
        return self._workers_per_node

    @workers_per_node.setter
    def workers_per_node(self, workers_per_node):
        """Sets the workers_per_node of this SyncPolicyExtended.

        The number of worker threads on a node performing a sync.  # noqa: E501

        :param workers_per_node: The workers_per_node of this SyncPolicyExtended.  # noqa: E501
        :type: int
        """
        if workers_per_node is not None and workers_per_node > 20:  # noqa: E501
            raise ValueError("Invalid value for `workers_per_node`, must be a value less than or equal to `20`")  # noqa: E501
        if workers_per_node is not None and workers_per_node < 1:  # noqa: E501
            raise ValueError("Invalid value for `workers_per_node`, must be a value greater than or equal to `1`")  # noqa: E501

        self._workers_per_node = workers_per_node

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SyncPolicyExtended):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
