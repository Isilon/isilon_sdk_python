# coding: utf-8

"""
    Isilon SDK

    Isilon SDK - Language bindings for the OneFS API  # noqa: E501

    OpenAPI spec version: 12
    Contact: sdk@isilon.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from isilon_sdk.v9_2_1.api_client import ApiClient


class UpgradeApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_cluster_add_remaining_node(self, cluster_add_remaining_node, **kwargs):  # noqa: E501
        """create_cluster_add_remaining_node  # noqa: E501

        Let system absorb any remaining or new nodes inside the existing upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_add_remaining_node(cluster_add_remaining_node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_add_remaining_node: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_add_remaining_node_with_http_info(cluster_add_remaining_node, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_add_remaining_node_with_http_info(cluster_add_remaining_node, **kwargs)  # noqa: E501
            return data

    def create_cluster_add_remaining_node_with_http_info(self, cluster_add_remaining_node, **kwargs):  # noqa: E501
        """create_cluster_add_remaining_node  # noqa: E501

        Let system absorb any remaining or new nodes inside the existing upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_add_remaining_node_with_http_info(cluster_add_remaining_node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_add_remaining_node: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_add_remaining_node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_add_remaining_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_add_remaining_node' is set
        if ('cluster_add_remaining_node' not in params or
                params['cluster_add_remaining_node'] is None):
            raise ValueError("Missing the required parameter `cluster_add_remaining_node` when calling `create_cluster_add_remaining_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_add_remaining_node' in params:
            body_params = params['cluster_add_remaining_node']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/3/upgrade/cluster/add_remaining_nodes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_archive_item(self, cluster_archive_item, **kwargs):  # noqa: E501
        """create_cluster_archive_item  # noqa: E501

        Start an archive of an upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_archive_item(cluster_archive_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterArchiveItem cluster_archive_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_archive_item_with_http_info(cluster_archive_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_archive_item_with_http_info(cluster_archive_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_archive_item_with_http_info(self, cluster_archive_item, **kwargs):  # noqa: E501
        """create_cluster_archive_item  # noqa: E501

        Start an archive of an upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_archive_item_with_http_info(cluster_archive_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterArchiveItem cluster_archive_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_archive_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_archive_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_archive_item' is set
        if ('cluster_archive_item' not in params or
                params['cluster_archive_item'] is None):
            raise ValueError("Missing the required parameter `cluster_archive_item` when calling `create_cluster_archive_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_archive_item' in params:
            body_params = params['cluster_archive_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/3/upgrade/cluster/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_assess_item(self, cluster_assess_item, **kwargs):  # noqa: E501
        """create_cluster_assess_item  # noqa: E501

        Start upgrade assessment on cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_assess_item(cluster_assess_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterAssessItem cluster_assess_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_assess_item_with_http_info(cluster_assess_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_assess_item_with_http_info(cluster_assess_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_assess_item_with_http_info(self, cluster_assess_item, **kwargs):  # noqa: E501
        """create_cluster_assess_item  # noqa: E501

        Start upgrade assessment on cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_assess_item_with_http_info(cluster_assess_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterAssessItem cluster_assess_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_assess_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_assess_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_assess_item' is set
        if ('cluster_assess_item' not in params or
                params['cluster_assess_item'] is None):
            raise ValueError("Missing the required parameter `cluster_assess_item` when calling `create_cluster_assess_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_assess_item' in params:
            body_params = params['cluster_assess_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/5/upgrade/cluster/assess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_commit_item(self, cluster_commit_item, **kwargs):  # noqa: E501
        """create_cluster_commit_item  # noqa: E501

        Commit the upgrade of a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_commit_item(cluster_commit_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_commit_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_commit_item_with_http_info(cluster_commit_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_commit_item_with_http_info(cluster_commit_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_commit_item_with_http_info(self, cluster_commit_item, **kwargs):  # noqa: E501
        """create_cluster_commit_item  # noqa: E501

        Commit the upgrade of a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_commit_item_with_http_info(cluster_commit_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_commit_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_commit_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_commit_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_commit_item' is set
        if ('cluster_commit_item' not in params or
                params['cluster_commit_item'] is None):
            raise ValueError("Missing the required parameter `cluster_commit_item` when calling `create_cluster_commit_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_commit_item' in params:
            body_params = params['cluster_commit_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/3/upgrade/cluster/commit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_firmware_assess_item(self, cluster_firmware_assess_item, **kwargs):  # noqa: E501
        """create_cluster_firmware_assess_item  # noqa: E501

        Start firmware upgrade assessment on cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_firmware_assess_item(cluster_firmware_assess_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterFirmwareAssessItem cluster_firmware_assess_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_firmware_assess_item_with_http_info(cluster_firmware_assess_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_firmware_assess_item_with_http_info(cluster_firmware_assess_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_firmware_assess_item_with_http_info(self, cluster_firmware_assess_item, **kwargs):  # noqa: E501
        """create_cluster_firmware_assess_item  # noqa: E501

        Start firmware upgrade assessment on cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_firmware_assess_item_with_http_info(cluster_firmware_assess_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterFirmwareAssessItem cluster_firmware_assess_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_firmware_assess_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_firmware_assess_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_firmware_assess_item' is set
        if ('cluster_firmware_assess_item' not in params or
                params['cluster_firmware_assess_item'] is None):
            raise ValueError("Missing the required parameter `cluster_firmware_assess_item` when calling `create_cluster_firmware_assess_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_firmware_assess_item' in params:
            body_params = params['cluster_firmware_assess_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/10/upgrade/cluster/firmware/assess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_firmware_upgrade_item(self, cluster_firmware_upgrade_item, **kwargs):  # noqa: E501
        """create_cluster_firmware_upgrade_item  # noqa: E501

        The settings necessary to start a firmware upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_firmware_upgrade_item(cluster_firmware_upgrade_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterFirmwareUpgradeItem cluster_firmware_upgrade_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_firmware_upgrade_item_with_http_info(cluster_firmware_upgrade_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_firmware_upgrade_item_with_http_info(cluster_firmware_upgrade_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_firmware_upgrade_item_with_http_info(self, cluster_firmware_upgrade_item, **kwargs):  # noqa: E501
        """create_cluster_firmware_upgrade_item  # noqa: E501

        The settings necessary to start a firmware upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_firmware_upgrade_item_with_http_info(cluster_firmware_upgrade_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterFirmwareUpgradeItem cluster_firmware_upgrade_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_firmware_upgrade_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_firmware_upgrade_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_firmware_upgrade_item' is set
        if ('cluster_firmware_upgrade_item' not in params or
                params['cluster_firmware_upgrade_item'] is None):
            raise ValueError("Missing the required parameter `cluster_firmware_upgrade_item` when calling `create_cluster_firmware_upgrade_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_firmware_upgrade_item' in params:
            body_params = params['cluster_firmware_upgrade_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/firmware/upgrade', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_patch_abort_item(self, cluster_patch_abort_item, **kwargs):  # noqa: E501
        """create_cluster_patch_abort_item  # noqa: E501

        Abort the previous action performed by the patch system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_patch_abort_item(cluster_patch_abort_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_patch_abort_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_patch_abort_item_with_http_info(cluster_patch_abort_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_patch_abort_item_with_http_info(cluster_patch_abort_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_patch_abort_item_with_http_info(self, cluster_patch_abort_item, **kwargs):  # noqa: E501
        """create_cluster_patch_abort_item  # noqa: E501

        Abort the previous action performed by the patch system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_patch_abort_item_with_http_info(cluster_patch_abort_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_patch_abort_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_patch_abort_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_patch_abort_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_patch_abort_item' is set
        if ('cluster_patch_abort_item' not in params or
                params['cluster_patch_abort_item'] is None):
            raise ValueError("Missing the required parameter `cluster_patch_abort_item` when calling `create_cluster_patch_abort_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_patch_abort_item' in params:
            body_params = params['cluster_patch_abort_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/3/upgrade/cluster/patch/abort', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_patch_patch(self, cluster_patch_patch, **kwargs):  # noqa: E501
        """create_cluster_patch_patch  # noqa: E501

        Install a patch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_patch_patch(cluster_patch_patch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterPatchPatch cluster_patch_patch: (required)
        :param str process_type: Process type can be 'simultaneous', 'rolling', or 'parallel'.
        :param bool skip_conflict_check: Bypass conflict checks. Defaults to false.
        :param bool skip_dependency_check: Bypass dependency checks. Defaults to false.
        :param bool skip_restricted_check: Bypass restricted checks. Defaults to false.
        :param bool skip_version_check: Bypass version checks. Defaults to false.
        :return: CreateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_patch_patch_with_http_info(cluster_patch_patch, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_patch_patch_with_http_info(cluster_patch_patch, **kwargs)  # noqa: E501
            return data

    def create_cluster_patch_patch_with_http_info(self, cluster_patch_patch, **kwargs):  # noqa: E501
        """create_cluster_patch_patch  # noqa: E501

        Install a patch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_patch_patch_with_http_info(cluster_patch_patch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterPatchPatch cluster_patch_patch: (required)
        :param str process_type: Process type can be 'simultaneous', 'rolling', or 'parallel'.
        :param bool skip_conflict_check: Bypass conflict checks. Defaults to false.
        :param bool skip_dependency_check: Bypass dependency checks. Defaults to false.
        :param bool skip_restricted_check: Bypass restricted checks. Defaults to false.
        :param bool skip_version_check: Bypass version checks. Defaults to false.
        :return: CreateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_patch_patch', 'process_type', 'skip_conflict_check', 'skip_dependency_check', 'skip_restricted_check', 'skip_version_check']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_patch_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_patch_patch' is set
        if ('cluster_patch_patch' not in params or
                params['cluster_patch_patch'] is None):
            raise ValueError("Missing the required parameter `cluster_patch_patch` when calling `create_cluster_patch_patch`")  # noqa: E501

        if ('process_type' in params and
                len(params['process_type']) > 255):
            raise ValueError("Invalid value for parameter `process_type` when calling `create_cluster_patch_patch`, length must be less than or equal to `255`")  # noqa: E501
        if ('process_type' in params and
                len(params['process_type']) < 6):
            raise ValueError("Invalid value for parameter `process_type` when calling `create_cluster_patch_patch`, length must be greater than or equal to `6`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'process_type' in params:
            query_params.append(('process_type', params['process_type']))  # noqa: E501
        if 'skip_conflict_check' in params:
            query_params.append(('skip_conflict_check', params['skip_conflict_check']))  # noqa: E501
        if 'skip_dependency_check' in params:
            query_params.append(('skip_dependency_check', params['skip_dependency_check']))  # noqa: E501
        if 'skip_restricted_check' in params:
            query_params.append(('skip_restricted_check', params['skip_restricted_check']))  # noqa: E501
        if 'skip_version_check' in params:
            query_params.append(('skip_version_check', params['skip_version_check']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_patch_patch' in params:
            body_params = params['cluster_patch_patch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/11/upgrade/cluster/patch/patches', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_pause_item(self, cluster_pause_item, **kwargs):  # noqa: E501
        """create_cluster_pause_item  # noqa: E501

        Pause a running upgrade process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_pause_item(cluster_pause_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_pause_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_pause_item_with_http_info(cluster_pause_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_pause_item_with_http_info(cluster_pause_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_pause_item_with_http_info(self, cluster_pause_item, **kwargs):  # noqa: E501
        """create_cluster_pause_item  # noqa: E501

        Pause a running upgrade process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_pause_item_with_http_info(cluster_pause_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_pause_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_pause_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_pause_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_pause_item' is set
        if ('cluster_pause_item' not in params or
                params['cluster_pause_item'] is None):
            raise ValueError("Missing the required parameter `cluster_pause_item` when calling `create_cluster_pause_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_pause_item' in params:
            body_params = params['cluster_pause_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/7/upgrade/cluster/pause', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_resume_item(self, cluster_resume_item, **kwargs):  # noqa: E501
        """create_cluster_resume_item  # noqa: E501

        Resume a paused upgrade process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_resume_item(cluster_resume_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_resume_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_resume_item_with_http_info(cluster_resume_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_resume_item_with_http_info(cluster_resume_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_resume_item_with_http_info(self, cluster_resume_item, **kwargs):  # noqa: E501
        """create_cluster_resume_item  # noqa: E501

        Resume a paused upgrade process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_resume_item_with_http_info(cluster_resume_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_resume_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_resume_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_resume_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_resume_item' is set
        if ('cluster_resume_item' not in params or
                params['cluster_resume_item'] is None):
            raise ValueError("Missing the required parameter `cluster_resume_item` when calling `create_cluster_resume_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_resume_item' in params:
            body_params = params['cluster_resume_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/7/upgrade/cluster/resume', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_retry_last_action_item(self, cluster_retry_last_action_item, **kwargs):  # noqa: E501
        """create_cluster_retry_last_action_item  # noqa: E501

        Retry the last upgrade action, in-case the previous attempt failed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_retry_last_action_item(cluster_retry_last_action_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterRetryLastActionItem cluster_retry_last_action_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_retry_last_action_item_with_http_info(cluster_retry_last_action_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_retry_last_action_item_with_http_info(cluster_retry_last_action_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_retry_last_action_item_with_http_info(self, cluster_retry_last_action_item, **kwargs):  # noqa: E501
        """create_cluster_retry_last_action_item  # noqa: E501

        Retry the last upgrade action, in-case the previous attempt failed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_retry_last_action_item_with_http_info(cluster_retry_last_action_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterRetryLastActionItem cluster_retry_last_action_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_retry_last_action_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_retry_last_action_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_retry_last_action_item' is set
        if ('cluster_retry_last_action_item' not in params or
                params['cluster_retry_last_action_item'] is None):
            raise ValueError("Missing the required parameter `cluster_retry_last_action_item` when calling `create_cluster_retry_last_action_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_retry_last_action_item' in params:
            body_params = params['cluster_retry_last_action_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/3/upgrade/cluster/retry_last_action', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_rollback_item(self, cluster_rollback_item, **kwargs):  # noqa: E501
        """create_cluster_rollback_item  # noqa: E501

        Rollback the upgrade of a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_rollback_item(cluster_rollback_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_rollback_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_rollback_item_with_http_info(cluster_rollback_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_rollback_item_with_http_info(cluster_rollback_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_rollback_item_with_http_info(self, cluster_rollback_item, **kwargs):  # noqa: E501
        """create_cluster_rollback_item  # noqa: E501

        Rollback the upgrade of a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_rollback_item_with_http_info(cluster_rollback_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Empty cluster_rollback_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_rollback_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_rollback_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_rollback_item' is set
        if ('cluster_rollback_item' not in params or
                params['cluster_rollback_item'] is None):
            raise ValueError("Missing the required parameter `cluster_rollback_item` when calling `create_cluster_rollback_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_rollback_item' in params:
            body_params = params['cluster_rollback_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/3/upgrade/cluster/rollback', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_upgrade_item(self, cluster_upgrade_item, **kwargs):  # noqa: E501
        """create_cluster_upgrade_item  # noqa: E501

        The settings necessary to start an upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_upgrade_item(cluster_upgrade_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterUpgradeItem cluster_upgrade_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_upgrade_item_with_http_info(cluster_upgrade_item, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_upgrade_item_with_http_info(cluster_upgrade_item, **kwargs)  # noqa: E501
            return data

    def create_cluster_upgrade_item_with_http_info(self, cluster_upgrade_item, **kwargs):  # noqa: E501
        """create_cluster_upgrade_item  # noqa: E501

        The settings necessary to start an upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_upgrade_item_with_http_info(cluster_upgrade_item, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterUpgradeItem cluster_upgrade_item: (required)
        :return: Empty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_upgrade_item']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_upgrade_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_upgrade_item' is set
        if ('cluster_upgrade_item' not in params or
                params['cluster_upgrade_item'] is None):
            raise ValueError("Missing the required parameter `cluster_upgrade_item` when calling `create_cluster_upgrade_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_upgrade_item' in params:
            body_params = params['cluster_upgrade_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/upgrade', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Empty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cluster_patch_patch(self, cluster_patch_patch_id, **kwargs):  # noqa: E501
        """delete_cluster_patch_patch  # noqa: E501

        Uninstall a patch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_patch_patch(cluster_patch_patch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_patch_patch_id: Uninstall a patch. (required)
        :param str process_type: Process type can be 'simultaneous', 'rolling', or 'parallel'
        :param bool skip_conflict_check: Bypass conflict checks. Defaults to false.
        :param bool skip_dependency_check: Bypass dependency checks. Defaults to false.
        :param bool skip_restricted_check: Bypass restricted checks. Defaults to false.
        :param bool skip_version_check: Bypass version checks. Defaults to false.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cluster_patch_patch_with_http_info(cluster_patch_patch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cluster_patch_patch_with_http_info(cluster_patch_patch_id, **kwargs)  # noqa: E501
            return data

    def delete_cluster_patch_patch_with_http_info(self, cluster_patch_patch_id, **kwargs):  # noqa: E501
        """delete_cluster_patch_patch  # noqa: E501

        Uninstall a patch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_patch_patch_with_http_info(cluster_patch_patch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_patch_patch_id: Uninstall a patch. (required)
        :param str process_type: Process type can be 'simultaneous', 'rolling', or 'parallel'
        :param bool skip_conflict_check: Bypass conflict checks. Defaults to false.
        :param bool skip_dependency_check: Bypass dependency checks. Defaults to false.
        :param bool skip_restricted_check: Bypass restricted checks. Defaults to false.
        :param bool skip_version_check: Bypass version checks. Defaults to false.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_patch_patch_id', 'process_type', 'skip_conflict_check', 'skip_dependency_check', 'skip_restricted_check', 'skip_version_check']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cluster_patch_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_patch_patch_id' is set
        if ('cluster_patch_patch_id' not in params or
                params['cluster_patch_patch_id'] is None):
            raise ValueError("Missing the required parameter `cluster_patch_patch_id` when calling `delete_cluster_patch_patch`")  # noqa: E501

        if ('process_type' in params and
                len(params['process_type']) > 255):
            raise ValueError("Invalid value for parameter `process_type` when calling `delete_cluster_patch_patch`, length must be less than or equal to `255`")  # noqa: E501
        if ('process_type' in params and
                len(params['process_type']) < 6):
            raise ValueError("Invalid value for parameter `process_type` when calling `delete_cluster_patch_patch`, length must be greater than or equal to `6`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cluster_patch_patch_id' in params:
            path_params['ClusterPatchPatchId'] = params['cluster_patch_patch_id']  # noqa: E501

        query_params = []
        if 'process_type' in params:
            query_params.append(('process_type', params['process_type']))  # noqa: E501
        if 'skip_conflict_check' in params:
            query_params.append(('skip_conflict_check', params['skip_conflict_check']))  # noqa: E501
        if 'skip_dependency_check' in params:
            query_params.append(('skip_dependency_check', params['skip_dependency_check']))  # noqa: E501
        if 'skip_restricted_check' in params:
            query_params.append(('skip_restricted_check', params['skip_restricted_check']))  # noqa: E501
        if 'skip_version_check' in params:
            query_params.append(('skip_version_check', params['skip_version_check']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/11/upgrade/cluster/patch/patches/{ClusterPatchPatchId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_drain_list(self, drain_list, **kwargs):  # noqa: E501
        """get_cluster_drain_list  # noqa: E501

        View Drain delay/skip lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_drain_list(drain_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str drain_list: Delay or Skip list. (required)
        :return: ClusterDrainList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_drain_list_with_http_info(drain_list, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_drain_list_with_http_info(drain_list, **kwargs)  # noqa: E501
            return data

    def get_cluster_drain_list_with_http_info(self, drain_list, **kwargs):  # noqa: E501
        """get_cluster_drain_list  # noqa: E501

        View Drain delay/skip lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_drain_list_with_http_info(drain_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str drain_list: Delay or Skip list. (required)
        :return: ClusterDrainList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['drain_list']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_drain_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'drain_list' is set
        if ('drain_list' not in params or
                params['drain_list'] is None):
            raise ValueError("Missing the required parameter `drain_list` when calling `get_cluster_drain_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'drain_list' in params:
            query_params.append(('drain_list', params['drain_list']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/drain/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterDrainList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_drain_timeout(self, **kwargs):  # noqa: E501
        """get_cluster_drain_timeout  # noqa: E501

        View or modify drain timeouts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_drain_timeout(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ClusterDrainTimeout
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_drain_timeout_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_drain_timeout_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cluster_drain_timeout_with_http_info(self, **kwargs):  # noqa: E501
        """get_cluster_drain_timeout  # noqa: E501

        View or modify drain timeouts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_drain_timeout_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ClusterDrainTimeout
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_drain_timeout" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/drain/timeout', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterDrainTimeout',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_firmware_device(self, **kwargs):  # noqa: E501
        """get_cluster_firmware_device  # noqa: E501

        The firmware status for the cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_firmware_device(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool devices: Show devices. If false, this returns an empty list. Default is false.
        :param bool package: Show package. If false, this returns an empty list. Default is false.
        :param bool refresh: Re-gather firmware status. Default is false.
        :return: ClusterFirmwareDevice
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_firmware_device_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_firmware_device_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cluster_firmware_device_with_http_info(self, **kwargs):  # noqa: E501
        """get_cluster_firmware_device  # noqa: E501

        The firmware status for the cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_firmware_device_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool devices: Show devices. If false, this returns an empty list. Default is false.
        :param bool package: Show package. If false, this returns an empty list. Default is false.
        :param bool refresh: Re-gather firmware status. Default is false.
        :return: ClusterFirmwareDevice
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['devices', 'package', 'refresh']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_firmware_device" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'devices' in params:
            query_params.append(('devices', params['devices']))  # noqa: E501
        if 'package' in params:
            query_params.append(('package', params['package']))  # noqa: E501
        if 'refresh' in params:
            query_params.append(('refresh', params['refresh']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/10/upgrade/cluster/firmware/device', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterFirmwareDevice',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_firmware_progress(self, **kwargs):  # noqa: E501
        """get_cluster_firmware_progress  # noqa: E501

        Cluster wide firmware upgrade status info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_firmware_progress(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ClusterFirmwareProgress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_firmware_progress_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_firmware_progress_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cluster_firmware_progress_with_http_info(self, **kwargs):  # noqa: E501
        """get_cluster_firmware_progress  # noqa: E501

        Cluster wide firmware upgrade status info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_firmware_progress_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ClusterFirmwareProgress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_firmware_progress" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/3/upgrade/cluster/firmware/progress', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterFirmwareProgress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_firmware_status(self, **kwargs):  # noqa: E501
        """get_cluster_firmware_status  # noqa: E501

        The firmware status for the cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_firmware_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool devices: Show devices. If false, this returns an empty list. Default is false.
        :param bool refresh: Re-gather firmware status. Default is false.
        :return: ClusterFirmwareStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_firmware_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_firmware_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cluster_firmware_status_with_http_info(self, **kwargs):  # noqa: E501
        """get_cluster_firmware_status  # noqa: E501

        The firmware status for the cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_firmware_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool devices: Show devices. If false, this returns an empty list. Default is false.
        :param bool refresh: Re-gather firmware status. Default is false.
        :return: ClusterFirmwareStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['devices', 'refresh']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_firmware_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'devices' in params:
            query_params.append(('devices', params['devices']))  # noqa: E501
        if 'refresh' in params:
            query_params.append(('refresh', params['refresh']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/10/upgrade/cluster/firmware/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterFirmwareStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_node(self, cluster_node_id, **kwargs):  # noqa: E501
        """get_cluster_node  # noqa: E501

        The node details useful during an upgrade or assessment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_node(cluster_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cluster_node_id: The node details useful during an upgrade or assessment. (required)
        :return: ClusterNodesExtendedExtended
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_node_with_http_info(cluster_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_node_with_http_info(cluster_node_id, **kwargs)  # noqa: E501
            return data

    def get_cluster_node_with_http_info(self, cluster_node_id, **kwargs):  # noqa: E501
        """get_cluster_node  # noqa: E501

        The node details useful during an upgrade or assessment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_node_with_http_info(cluster_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cluster_node_id: The node details useful during an upgrade or assessment. (required)
        :return: ClusterNodesExtendedExtended
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_node_id' is set
        if ('cluster_node_id' not in params or
                params['cluster_node_id'] is None):
            raise ValueError("Missing the required parameter `cluster_node_id` when calling `get_cluster_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_node_id' in params:
            path_params['ClusterNodeId'] = params['cluster_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/nodes/{ClusterNodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterNodesExtendedExtended',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_nodes(self, **kwargs):  # noqa: E501
        """get_cluster_nodes  # noqa: E501

        View information about nodes during an upgrade, rollback, or pre-upgrade assessment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_nodes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool by_domain: If true, tag nodes that are assigned to like-failure domains
        :return: ClusterNodesExtendedExtendedExtended
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_nodes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_nodes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cluster_nodes_with_http_info(self, **kwargs):  # noqa: E501
        """get_cluster_nodes  # noqa: E501

        View information about nodes during an upgrade, rollback, or pre-upgrade assessment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_nodes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool by_domain: If true, tag nodes that are assigned to like-failure domains
        :return: ClusterNodesExtendedExtendedExtended
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['by_domain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_nodes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'by_domain' in params:
            query_params.append(('by_domain', params['by_domain']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/nodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterNodesExtendedExtendedExtended',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_patch_patch(self, cluster_patch_patch_id, **kwargs):  # noqa: E501
        """get_cluster_patch_patch  # noqa: E501

        View a single patch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_patch_patch(cluster_patch_patch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_patch_patch_id: View a single patch. (required)
        :param bool local: View patch information on local node only.
        :param str location: Path location of patch file.
        :return: ClusterPatchPatches
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_patch_patch_with_http_info(cluster_patch_patch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_patch_patch_with_http_info(cluster_patch_patch_id, **kwargs)  # noqa: E501
            return data

    def get_cluster_patch_patch_with_http_info(self, cluster_patch_patch_id, **kwargs):  # noqa: E501
        """get_cluster_patch_patch  # noqa: E501

        View a single patch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_patch_patch_with_http_info(cluster_patch_patch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_patch_patch_id: View a single patch. (required)
        :param bool local: View patch information on local node only.
        :param str location: Path location of patch file.
        :return: ClusterPatchPatches
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_patch_patch_id', 'local', 'location']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_patch_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_patch_patch_id' is set
        if ('cluster_patch_patch_id' not in params or
                params['cluster_patch_patch_id'] is None):
            raise ValueError("Missing the required parameter `cluster_patch_patch_id` when calling `get_cluster_patch_patch`")  # noqa: E501

        if ('location' in params and
                len(params['location']) > 4096):
            raise ValueError("Invalid value for parameter `location` when calling `get_cluster_patch_patch`, length must be less than or equal to `4096`")  # noqa: E501
        if ('location' in params and
                len(params['location']) < 0):
            raise ValueError("Invalid value for parameter `location` when calling `get_cluster_patch_patch`, length must be greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cluster_patch_patch_id' in params:
            path_params['ClusterPatchPatchId'] = params['cluster_patch_patch_id']  # noqa: E501

        query_params = []
        if 'local' in params:
            query_params.append(('local', params['local']))  # noqa: E501
        if 'location' in params:
            query_params.append(('location', params['location']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/11/upgrade/cluster/patch/patches/{ClusterPatchPatchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterPatchPatches',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_upgrade_cluster(self, **kwargs):  # noqa: E501
        """get_upgrade_cluster  # noqa: E501

        Cluster wide upgrade status info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_upgrade_cluster(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: UpgradeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_upgrade_cluster_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_upgrade_cluster_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_upgrade_cluster_with_http_info(self, **kwargs):  # noqa: E501
        """get_upgrade_cluster  # noqa: E501

        Cluster wide upgrade status info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_upgrade_cluster_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: UpgradeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_upgrade_cluster" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/7/upgrade/cluster', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpgradeCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_cluster_patch_patches(self, **kwargs):  # noqa: E501
        """list_cluster_patch_patches  # noqa: E501

        List all patches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_cluster_patch_patches(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dir: The direction of the sort.
        :param int limit: Return no more than this many results at once (see resume).
        :param bool local: View patches on the local node only.
        :param str location: Path location of patch file.
        :param str resume: Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
        :param str sort: The field that will be used for sorting.
        :return: ClusterPatchPatchesExtended
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_cluster_patch_patches_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_cluster_patch_patches_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_cluster_patch_patches_with_http_info(self, **kwargs):  # noqa: E501
        """list_cluster_patch_patches  # noqa: E501

        List all patches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_cluster_patch_patches_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dir: The direction of the sort.
        :param int limit: Return no more than this many results at once (see resume).
        :param bool local: View patches on the local node only.
        :param str location: Path location of patch file.
        :param str resume: Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
        :param str sort: The field that will be used for sorting.
        :return: ClusterPatchPatchesExtended
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dir', 'limit', 'local', 'location', 'resume', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cluster_patch_patches" % key
                )
            params[key] = val
        del params['kwargs']

        if ('dir' in params and
                len(params['dir']) < 0):
            raise ValueError("Invalid value for parameter `dir` when calling `list_cluster_patch_patches`, length must be greater than or equal to `0`")  # noqa: E501
        if 'limit' in params and params['limit'] > 4294967295:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_cluster_patch_patches`, must be a value less than or equal to `4294967295`")  # noqa: E501
        if 'limit' in params and params['limit'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_cluster_patch_patches`, must be a value greater than or equal to `1`")  # noqa: E501
        if ('location' in params and
                len(params['location']) > 4096):
            raise ValueError("Invalid value for parameter `location` when calling `list_cluster_patch_patches`, length must be less than or equal to `4096`")  # noqa: E501
        if ('location' in params and
                len(params['location']) < 0):
            raise ValueError("Invalid value for parameter `location` when calling `list_cluster_patch_patches`, length must be greater than or equal to `0`")  # noqa: E501
        if ('resume' in params and
                len(params['resume']) > 8192):
            raise ValueError("Invalid value for parameter `resume` when calling `list_cluster_patch_patches`, length must be less than or equal to `8192`")  # noqa: E501
        if ('resume' in params and
                len(params['resume']) < 0):
            raise ValueError("Invalid value for parameter `resume` when calling `list_cluster_patch_patches`, length must be greater than or equal to `0`")  # noqa: E501
        if ('sort' in params and
                len(params['sort']) > 255):
            raise ValueError("Invalid value for parameter `sort` when calling `list_cluster_patch_patches`, length must be less than or equal to `255`")  # noqa: E501
        if ('sort' in params and
                len(params['sort']) < 0):
            raise ValueError("Invalid value for parameter `sort` when calling `list_cluster_patch_patches`, length must be greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dir' in params:
            query_params.append(('dir', params['dir']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'local' in params:
            query_params.append(('local', params['local']))  # noqa: E501
        if 'location' in params:
            query_params.append(('location', params['location']))  # noqa: E501
        if 'resume' in params:
            query_params.append(('resume', params['resume']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/11/upgrade/cluster/patch/patches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterPatchPatchesExtended',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cluster_drain(self, cluster_drain, **kwargs):  # noqa: E501
        """update_cluster_drain  # noqa: E501

        Alter drain action.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_drain(cluster_drain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterDrain cluster_drain: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cluster_drain_with_http_info(cluster_drain, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cluster_drain_with_http_info(cluster_drain, **kwargs)  # noqa: E501
            return data

    def update_cluster_drain_with_http_info(self, cluster_drain, **kwargs):  # noqa: E501
        """update_cluster_drain  # noqa: E501

        Alter drain action.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_drain_with_http_info(cluster_drain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterDrain cluster_drain: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_drain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cluster_drain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_drain' is set
        if ('cluster_drain' not in params or
                params['cluster_drain'] is None):
            raise ValueError("Missing the required parameter `cluster_drain` when calling `update_cluster_drain`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_drain' in params:
            body_params = params['cluster_drain']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/drain', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cluster_drain_timeout(self, cluster_drain_timeout, **kwargs):  # noqa: E501
        """update_cluster_drain_timeout  # noqa: E501

        View or modify drain timeouts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_drain_timeout(cluster_drain_timeout, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterDrainTimeout cluster_drain_timeout: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cluster_drain_timeout_with_http_info(cluster_drain_timeout, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cluster_drain_timeout_with_http_info(cluster_drain_timeout, **kwargs)  # noqa: E501
            return data

    def update_cluster_drain_timeout_with_http_info(self, cluster_drain_timeout, **kwargs):  # noqa: E501
        """update_cluster_drain_timeout  # noqa: E501

        View or modify drain timeouts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_drain_timeout_with_http_info(cluster_drain_timeout, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterDrainTimeout cluster_drain_timeout: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_drain_timeout']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cluster_drain_timeout" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_drain_timeout' is set
        if ('cluster_drain_timeout' not in params or
                params['cluster_drain_timeout'] is None):
            raise ValueError("Missing the required parameter `cluster_drain_timeout` when calling `update_cluster_drain_timeout`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_drain_timeout' in params:
            body_params = params['cluster_drain_timeout']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/drain/timeout', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cluster_unblock(self, cluster_unblock, **kwargs):  # noqa: E501
        """update_cluster_unblock  # noqa: E501

        Unblock parallel upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_unblock(cluster_unblock, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterUnblock cluster_unblock: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cluster_unblock_with_http_info(cluster_unblock, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cluster_unblock_with_http_info(cluster_unblock, **kwargs)  # noqa: E501
            return data

    def update_cluster_unblock_with_http_info(self, cluster_unblock, **kwargs):  # noqa: E501
        """update_cluster_unblock  # noqa: E501

        Unblock parallel upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_unblock_with_http_info(cluster_unblock, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterUnblock cluster_unblock: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_unblock']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cluster_unblock" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_unblock' is set
        if ('cluster_unblock' not in params or
                params['cluster_unblock'] is None):
            raise ValueError("Missing the required parameter `cluster_unblock` when calling `update_cluster_unblock`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_unblock' in params:
            body_params = params['cluster_unblock']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/9/upgrade/cluster/unblock', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cluster_upgrade(self, cluster_upgrade, **kwargs):  # noqa: E501
        """update_cluster_upgrade  # noqa: E501

        Add nodes to a running upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_upgrade(cluster_upgrade, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterUpgrade cluster_upgrade: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cluster_upgrade_with_http_info(cluster_upgrade, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cluster_upgrade_with_http_info(cluster_upgrade, **kwargs)  # noqa: E501
            return data

    def update_cluster_upgrade_with_http_info(self, cluster_upgrade, **kwargs):  # noqa: E501
        """update_cluster_upgrade  # noqa: E501

        Add nodes to a running upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_upgrade_with_http_info(cluster_upgrade, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterUpgrade cluster_upgrade: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_upgrade']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cluster_upgrade" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_upgrade' is set
        if ('cluster_upgrade' not in params or
                params['cluster_upgrade'] is None):
            raise ValueError("Missing the required parameter `cluster_upgrade` when calling `update_cluster_upgrade`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_upgrade' in params:
            body_params = params['cluster_upgrade']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/platform/12/upgrade/cluster/upgrade', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
