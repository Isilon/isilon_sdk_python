# coding: utf-8

"""
    Isilon SDK

    Isilon SDK - Language bindings for the OneFS API  # noqa: E501

    OpenAPI spec version: 16
    Contact: sdk@isilon.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class OsSecurityNode(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'id': 'int',
        'kern_elf32_allow_wx': 'bool',
        'kern_elf32_aslr_enable': 'bool',
        'kern_elf32_aslr_pie_enable': 'bool',
        'kern_elf32_aslr_stack_gap': 'int',
        'kern_elf32_nxstack': 'bool',
        'kern_elf64_allow_wx': 'bool',
        'kern_elf64_aslr_enable': 'bool',
        'kern_elf64_aslr_pie_enable': 'bool',
        'kern_elf64_aslr_stack_gap': 'int',
        'kern_elf64_nxstack': 'bool',
        'lnn': 'int',
        'vm_aslr_restarts': 'int'
    }

    attribute_map = {
        'id': 'id',
        'kern_elf32_allow_wx': 'kern.elf32.allow_wx',
        'kern_elf32_aslr_enable': 'kern.elf32.aslr.enable',
        'kern_elf32_aslr_pie_enable': 'kern.elf32.aslr.pie_enable',
        'kern_elf32_aslr_stack_gap': 'kern.elf32.aslr.stack_gap',
        'kern_elf32_nxstack': 'kern.elf32.nxstack',
        'kern_elf64_allow_wx': 'kern.elf64.allow_wx',
        'kern_elf64_aslr_enable': 'kern.elf64.aslr.enable',
        'kern_elf64_aslr_pie_enable': 'kern.elf64.aslr.pie_enable',
        'kern_elf64_aslr_stack_gap': 'kern.elf64.aslr.stack_gap',
        'kern_elf64_nxstack': 'kern.elf64.nxstack',
        'lnn': 'lnn',
        'vm_aslr_restarts': 'vm.aslr_restarts'
    }

    def __init__(self, id=None, kern_elf32_allow_wx=None, kern_elf32_aslr_enable=None, kern_elf32_aslr_pie_enable=None, kern_elf32_aslr_stack_gap=None, kern_elf32_nxstack=None, kern_elf64_allow_wx=None, kern_elf64_aslr_enable=None, kern_elf64_aslr_pie_enable=None, kern_elf64_aslr_stack_gap=None, kern_elf64_nxstack=None, lnn=None, vm_aslr_restarts=None):  # noqa: E501
        """OsSecurityNode - a model defined in Swagger"""  # noqa: E501

        self._id = None
        self._kern_elf32_allow_wx = None
        self._kern_elf32_aslr_enable = None
        self._kern_elf32_aslr_pie_enable = None
        self._kern_elf32_aslr_stack_gap = None
        self._kern_elf32_nxstack = None
        self._kern_elf64_allow_wx = None
        self._kern_elf64_aslr_enable = None
        self._kern_elf64_aslr_pie_enable = None
        self._kern_elf64_aslr_stack_gap = None
        self._kern_elf64_nxstack = None
        self._lnn = None
        self._vm_aslr_restarts = None
        self.discriminator = None

        if id is not None:
            self.id = id
        if kern_elf32_allow_wx is not None:
            self.kern_elf32_allow_wx = kern_elf32_allow_wx
        if kern_elf32_aslr_enable is not None:
            self.kern_elf32_aslr_enable = kern_elf32_aslr_enable
        if kern_elf32_aslr_pie_enable is not None:
            self.kern_elf32_aslr_pie_enable = kern_elf32_aslr_pie_enable
        if kern_elf32_aslr_stack_gap is not None:
            self.kern_elf32_aslr_stack_gap = kern_elf32_aslr_stack_gap
        if kern_elf32_nxstack is not None:
            self.kern_elf32_nxstack = kern_elf32_nxstack
        if kern_elf64_allow_wx is not None:
            self.kern_elf64_allow_wx = kern_elf64_allow_wx
        if kern_elf64_aslr_enable is not None:
            self.kern_elf64_aslr_enable = kern_elf64_aslr_enable
        if kern_elf64_aslr_pie_enable is not None:
            self.kern_elf64_aslr_pie_enable = kern_elf64_aslr_pie_enable
        if kern_elf64_aslr_stack_gap is not None:
            self.kern_elf64_aslr_stack_gap = kern_elf64_aslr_stack_gap
        if kern_elf64_nxstack is not None:
            self.kern_elf64_nxstack = kern_elf64_nxstack
        if lnn is not None:
            self.lnn = lnn
        if vm_aslr_restarts is not None:
            self.vm_aslr_restarts = vm_aslr_restarts

    @property
    def id(self):
        """Gets the id of this OsSecurityNode.  # noqa: E501

        Sequence ID.  # noqa: E501

        :return: The id of this OsSecurityNode.  # noqa: E501
        :rtype: int
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this OsSecurityNode.

        Sequence ID.  # noqa: E501

        :param id: The id of this OsSecurityNode.  # noqa: E501
        :type: int
        """
        if id is not None and id > 4294967295:  # noqa: E501
            raise ValueError("Invalid value for `id`, must be a value less than or equal to `4294967295`")  # noqa: E501
        if id is not None and id < 1:  # noqa: E501
            raise ValueError("Invalid value for `id`, must be a value greater than or equal to `1`")  # noqa: E501

        self._id = id

    @property
    def kern_elf32_allow_wx(self):
        """Gets the kern_elf32_allow_wx of this OsSecurityNode.  # noqa: E501

        [ELF32] Allow pages to be mapped simultaneously writable and executable.  # noqa: E501

        :return: The kern_elf32_allow_wx of this OsSecurityNode.  # noqa: E501
        :rtype: bool
        """
        return self._kern_elf32_allow_wx

    @kern_elf32_allow_wx.setter
    def kern_elf32_allow_wx(self, kern_elf32_allow_wx):
        """Sets the kern_elf32_allow_wx of this OsSecurityNode.

        [ELF32] Allow pages to be mapped simultaneously writable and executable.  # noqa: E501

        :param kern_elf32_allow_wx: The kern_elf32_allow_wx of this OsSecurityNode.  # noqa: E501
        :type: bool
        """

        self._kern_elf32_allow_wx = kern_elf32_allow_wx

    @property
    def kern_elf32_aslr_enable(self):
        """Gets the kern_elf32_aslr_enable of this OsSecurityNode.  # noqa: E501

        [ELF32] Enable address map randomization.  # noqa: E501

        :return: The kern_elf32_aslr_enable of this OsSecurityNode.  # noqa: E501
        :rtype: bool
        """
        return self._kern_elf32_aslr_enable

    @kern_elf32_aslr_enable.setter
    def kern_elf32_aslr_enable(self, kern_elf32_aslr_enable):
        """Sets the kern_elf32_aslr_enable of this OsSecurityNode.

        [ELF32] Enable address map randomization.  # noqa: E501

        :param kern_elf32_aslr_enable: The kern_elf32_aslr_enable of this OsSecurityNode.  # noqa: E501
        :type: bool
        """

        self._kern_elf32_aslr_enable = kern_elf32_aslr_enable

    @property
    def kern_elf32_aslr_pie_enable(self):
        """Gets the kern_elf32_aslr_pie_enable of this OsSecurityNode.  # noqa: E501

        [ELF32] Enable address map randomization for PIE binaries.  # noqa: E501

        :return: The kern_elf32_aslr_pie_enable of this OsSecurityNode.  # noqa: E501
        :rtype: bool
        """
        return self._kern_elf32_aslr_pie_enable

    @kern_elf32_aslr_pie_enable.setter
    def kern_elf32_aslr_pie_enable(self, kern_elf32_aslr_pie_enable):
        """Sets the kern_elf32_aslr_pie_enable of this OsSecurityNode.

        [ELF32] Enable address map randomization for PIE binaries.  # noqa: E501

        :param kern_elf32_aslr_pie_enable: The kern_elf32_aslr_pie_enable of this OsSecurityNode.  # noqa: E501
        :type: bool
        """

        self._kern_elf32_aslr_pie_enable = kern_elf32_aslr_pie_enable

    @property
    def kern_elf32_aslr_stack_gap(self):
        """Gets the kern_elf32_aslr_stack_gap of this OsSecurityNode.  # noqa: E501

        [ELF32] Maximum percentage of main stack to waste on a random gap.  # noqa: E501

        :return: The kern_elf32_aslr_stack_gap of this OsSecurityNode.  # noqa: E501
        :rtype: int
        """
        return self._kern_elf32_aslr_stack_gap

    @kern_elf32_aslr_stack_gap.setter
    def kern_elf32_aslr_stack_gap(self, kern_elf32_aslr_stack_gap):
        """Sets the kern_elf32_aslr_stack_gap of this OsSecurityNode.

        [ELF32] Maximum percentage of main stack to waste on a random gap.  # noqa: E501

        :param kern_elf32_aslr_stack_gap: The kern_elf32_aslr_stack_gap of this OsSecurityNode.  # noqa: E501
        :type: int
        """
        if kern_elf32_aslr_stack_gap is not None and kern_elf32_aslr_stack_gap > 100:  # noqa: E501
            raise ValueError("Invalid value for `kern_elf32_aslr_stack_gap`, must be a value less than or equal to `100`")  # noqa: E501
        if kern_elf32_aslr_stack_gap is not None and kern_elf32_aslr_stack_gap < 0:  # noqa: E501
            raise ValueError("Invalid value for `kern_elf32_aslr_stack_gap`, must be a value greater than or equal to `0`")  # noqa: E501

        self._kern_elf32_aslr_stack_gap = kern_elf32_aslr_stack_gap

    @property
    def kern_elf32_nxstack(self):
        """Gets the kern_elf32_nxstack of this OsSecurityNode.  # noqa: E501

        [ELF32] Enable non-executable stack.  # noqa: E501

        :return: The kern_elf32_nxstack of this OsSecurityNode.  # noqa: E501
        :rtype: bool
        """
        return self._kern_elf32_nxstack

    @kern_elf32_nxstack.setter
    def kern_elf32_nxstack(self, kern_elf32_nxstack):
        """Sets the kern_elf32_nxstack of this OsSecurityNode.

        [ELF32] Enable non-executable stack.  # noqa: E501

        :param kern_elf32_nxstack: The kern_elf32_nxstack of this OsSecurityNode.  # noqa: E501
        :type: bool
        """

        self._kern_elf32_nxstack = kern_elf32_nxstack

    @property
    def kern_elf64_allow_wx(self):
        """Gets the kern_elf64_allow_wx of this OsSecurityNode.  # noqa: E501

        [ELF64] Allow pages to be mapped simultaneously writable and executable.  # noqa: E501

        :return: The kern_elf64_allow_wx of this OsSecurityNode.  # noqa: E501
        :rtype: bool
        """
        return self._kern_elf64_allow_wx

    @kern_elf64_allow_wx.setter
    def kern_elf64_allow_wx(self, kern_elf64_allow_wx):
        """Sets the kern_elf64_allow_wx of this OsSecurityNode.

        [ELF64] Allow pages to be mapped simultaneously writable and executable.  # noqa: E501

        :param kern_elf64_allow_wx: The kern_elf64_allow_wx of this OsSecurityNode.  # noqa: E501
        :type: bool
        """

        self._kern_elf64_allow_wx = kern_elf64_allow_wx

    @property
    def kern_elf64_aslr_enable(self):
        """Gets the kern_elf64_aslr_enable of this OsSecurityNode.  # noqa: E501

        [ELF64] Enable address map randomization.  # noqa: E501

        :return: The kern_elf64_aslr_enable of this OsSecurityNode.  # noqa: E501
        :rtype: bool
        """
        return self._kern_elf64_aslr_enable

    @kern_elf64_aslr_enable.setter
    def kern_elf64_aslr_enable(self, kern_elf64_aslr_enable):
        """Sets the kern_elf64_aslr_enable of this OsSecurityNode.

        [ELF64] Enable address map randomization.  # noqa: E501

        :param kern_elf64_aslr_enable: The kern_elf64_aslr_enable of this OsSecurityNode.  # noqa: E501
        :type: bool
        """

        self._kern_elf64_aslr_enable = kern_elf64_aslr_enable

    @property
    def kern_elf64_aslr_pie_enable(self):
        """Gets the kern_elf64_aslr_pie_enable of this OsSecurityNode.  # noqa: E501

        [ELF64] Enable address map randomization for PIE binaries.  # noqa: E501

        :return: The kern_elf64_aslr_pie_enable of this OsSecurityNode.  # noqa: E501
        :rtype: bool
        """
        return self._kern_elf64_aslr_pie_enable

    @kern_elf64_aslr_pie_enable.setter
    def kern_elf64_aslr_pie_enable(self, kern_elf64_aslr_pie_enable):
        """Sets the kern_elf64_aslr_pie_enable of this OsSecurityNode.

        [ELF64] Enable address map randomization for PIE binaries.  # noqa: E501

        :param kern_elf64_aslr_pie_enable: The kern_elf64_aslr_pie_enable of this OsSecurityNode.  # noqa: E501
        :type: bool
        """

        self._kern_elf64_aslr_pie_enable = kern_elf64_aslr_pie_enable

    @property
    def kern_elf64_aslr_stack_gap(self):
        """Gets the kern_elf64_aslr_stack_gap of this OsSecurityNode.  # noqa: E501

        [ELF32] Maximum percentage of main stack to waste on a random gap.  # noqa: E501

        :return: The kern_elf64_aslr_stack_gap of this OsSecurityNode.  # noqa: E501
        :rtype: int
        """
        return self._kern_elf64_aslr_stack_gap

    @kern_elf64_aslr_stack_gap.setter
    def kern_elf64_aslr_stack_gap(self, kern_elf64_aslr_stack_gap):
        """Sets the kern_elf64_aslr_stack_gap of this OsSecurityNode.

        [ELF32] Maximum percentage of main stack to waste on a random gap.  # noqa: E501

        :param kern_elf64_aslr_stack_gap: The kern_elf64_aslr_stack_gap of this OsSecurityNode.  # noqa: E501
        :type: int
        """
        if kern_elf64_aslr_stack_gap is not None and kern_elf64_aslr_stack_gap > 100:  # noqa: E501
            raise ValueError("Invalid value for `kern_elf64_aslr_stack_gap`, must be a value less than or equal to `100`")  # noqa: E501
        if kern_elf64_aslr_stack_gap is not None and kern_elf64_aslr_stack_gap < 0:  # noqa: E501
            raise ValueError("Invalid value for `kern_elf64_aslr_stack_gap`, must be a value greater than or equal to `0`")  # noqa: E501

        self._kern_elf64_aslr_stack_gap = kern_elf64_aslr_stack_gap

    @property
    def kern_elf64_nxstack(self):
        """Gets the kern_elf64_nxstack of this OsSecurityNode.  # noqa: E501

        [ELF64] Enable non-executable stack.  # noqa: E501

        :return: The kern_elf64_nxstack of this OsSecurityNode.  # noqa: E501
        :rtype: bool
        """
        return self._kern_elf64_nxstack

    @kern_elf64_nxstack.setter
    def kern_elf64_nxstack(self, kern_elf64_nxstack):
        """Sets the kern_elf64_nxstack of this OsSecurityNode.

        [ELF64] Enable non-executable stack.  # noqa: E501

        :param kern_elf64_nxstack: The kern_elf64_nxstack of this OsSecurityNode.  # noqa: E501
        :type: bool
        """

        self._kern_elf64_nxstack = kern_elf64_nxstack

    @property
    def lnn(self):
        """Gets the lnn of this OsSecurityNode.  # noqa: E501

        Logical Node Number.  # noqa: E501

        :return: The lnn of this OsSecurityNode.  # noqa: E501
        :rtype: int
        """
        return self._lnn

    @lnn.setter
    def lnn(self, lnn):
        """Sets the lnn of this OsSecurityNode.

        Logical Node Number.  # noqa: E501

        :param lnn: The lnn of this OsSecurityNode.  # noqa: E501
        :type: int
        """
        if lnn is not None and lnn > 4294967295:  # noqa: E501
            raise ValueError("Invalid value for `lnn`, must be a value less than or equal to `4294967295`")  # noqa: E501
        if lnn is not None and lnn < 1:  # noqa: E501
            raise ValueError("Invalid value for `lnn`, must be a value greater than or equal to `1`")  # noqa: E501

        self._lnn = lnn

    @property
    def vm_aslr_restarts(self):
        """Gets the vm_aslr_restarts of this OsSecurityNode.  # noqa: E501

        Number of aslr failures.  # noqa: E501

        :return: The vm_aslr_restarts of this OsSecurityNode.  # noqa: E501
        :rtype: int
        """
        return self._vm_aslr_restarts

    @vm_aslr_restarts.setter
    def vm_aslr_restarts(self, vm_aslr_restarts):
        """Sets the vm_aslr_restarts of this OsSecurityNode.

        Number of aslr failures.  # noqa: E501

        :param vm_aslr_restarts: The vm_aslr_restarts of this OsSecurityNode.  # noqa: E501
        :type: int
        """
        if vm_aslr_restarts is not None and vm_aslr_restarts > 9223372036854775807:  # noqa: E501
            raise ValueError("Invalid value for `vm_aslr_restarts`, must be a value less than or equal to `9223372036854775807`")  # noqa: E501
        if vm_aslr_restarts is not None and vm_aslr_restarts < 0:  # noqa: E501
            raise ValueError("Invalid value for `vm_aslr_restarts`, must be a value greater than or equal to `0`")  # noqa: E501

        self._vm_aslr_restarts = vm_aslr_restarts

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, OsSecurityNode):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
